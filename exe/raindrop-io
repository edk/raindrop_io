#!/usr/bin/env ruby

require_relative "../lib/raindrop_io"
require "dotenv/load"
require "optparse"
require "json"
require "logger"
require "awesome_print"
require "sqlite3"
require "pg"
require "active_record"
require "openai"
require "tty-prompt"
require "tty-table"
require "tty-pager"
require "pastel"
require "readability"
require "poppler"
require "net/http"
require "uri"
require "open-uri"
require "tanakai"
require "cgi"
require "yt"

class Command
  attr_accessor :command, :object, :options, :token

  def initialize(args)
    if !File.exist?(".env")
      usage
    end
    keys = %w[RAINDROP_TOKEN OPENAI_API_KEY YOUTUBE_API_KEY]
    missing = []
    keys.each do |key|
      missing << key unless ENV[key].to_s.size > 0
    end
    if missing.any?
      warn "Missing required environment variables: #{missing.join(", ")}\n\n"
      usage
    end
  end

  def usage
    warn "Usage: #{$0}\n\n"
    warn " Set required variables in .env file\n"
    warn "  RAINDROP_API_TOKEN=your_token\n"
    warn "  OPENAI_API_KEY=your_key\n"
    warn "  YOUTUBE_API_KEY=your_key\n"
    exit 1
  end
end

command = Command.new(ARGV)
Yt.configure do |config|
  config.log_level = :debug
  config.api_key = ENV["YOUTUBE_API_KEY"]
end

$logger = Logger.new("raindrop_io.log") # rubocop:disable Style/GlobalVars
$logger.level = Logger::DEBUG # rubocop:disable Style/GlobalVars

RaindropIo::Api.configure do |config|
  config.api_token = ENV["RAINDROP_TOKEN"]
  config.logger = $logger # rubocop:disable Style/GlobalVars
end

class Collection < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    collection_attrs = {
      int_fields: %w[_id count sort],
      string_fields: %w[color created lastUpdate title view description],
      bool_fields: %w[expanded public],
      object_fields: %w[access collaborators cover parent user creatorRef],
      extra_fields: %w[broken cache file important highlights lastAction slug author extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:collections)
        create_table :collections do |t|
          attrs = collection_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end
    end
  end
end

# | \_id             | `Integer`       | The id of the collection.
# | access           | `Object`
# | access.level     | `Integer`       | 1.  read only access (equal to `public=true`)  2.  collaborator with read only access  3.  collaborator with write only access  4.  owner
# | access.draggable | `Boolean`       | Does it possible to change parent of this collection?
# | collaborators    | `Object`        | When this object is present, means that collections is shared. Content of this object is private and not very useful. All sharing API methods [described here](https://developer.raindrop.io/v1/collections/sharing) |
# | color            | `String`        | Primary color of collection cover as `HEX`
# | count            | `Integer`       | Count of raindrops in collection
# | cover            | `Array<String>` | Collection cover URL. This array always have one item due to legacy reasons
# | created          | `String`        | When collection is created
# | expanded         | `Boolean`       | Whether the collectionâ€™s sub-collections are expanded
# | lastUpdate       | `String`        | When collection is updated
# | parent           | `Object`
# | parent.$id       | `Integer`       | The id of the parent collection. Not specified for root collections
# | public           | `Boolean`       | Collection and raindrops that it contains will be accessible without authentication by public link
# | sort             | `Integer`       | The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
# | title            | `String`        | Name of the collection
# | user             | `Object`
# | user.$id         | `Integer`       | Owner ID
# | view             | `String`        | View style of collection, can be:*   `list` (default) `simple` `grid` `masonry` Pinterest like grid
class Raindrop < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    raindrop_attrs = {
      int_fields: %w[_id count sort collectionId],
      string_fields: %w[color created domain excerpt note cover lastUpdate title type view link],
      bool_fields: %w[broken expanded public important removed],
      object_fields: %w[collection media tags collaborators parent user creatorRef cache file highlights reminder],
      extra_fields: %w[extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:raindrops)
        create_table :raindrops do |t|
          attrs = raindrop_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end # unless
    end
  end

  def resolve_uri(base_uri, new_location)
    new_location.tr!("\\", "/")
    return URI(new_location) if new_location.start_with?("http")
    URI.join(base_uri, new_location)
  end

  def fetch_uri(uri, limit: 10)
    raise ArgumentError, "HTTP redirect too deep" if limit.zero?

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == "https"
    request = Net::HTTP::Get.new(uri.request_uri)
    request["User-Agent"] = ["Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"]

    response = http.request(request)

    case response
    when Net::HTTPSuccess
      response
    when Net::HTTPRedirection
      fetch_uri(resolve_uri(uri, response["location"]), limit: limit - 1)
    else
      response
    end
  end

  def scrape_url(url, debug: false)
    source_url = URI.parse(url)
    response = fetch_uri(source_url)

    binding.pry if debug # rubocop:disable Lint/Debugger
    content_type = response["content-type"]
    if /forbidden/i.match?(response.message) ||
        /You need to enable JavaScript/i.match?(response.body)
      use_puppeteer = true
      force_html = true
      content_type = "text/html"
    else
      use_puppeteer = false
      force_html = false
    end
    puts "DEBUG: content_type: #{content_type} force_html: #{force_html} use_puppeteer: #{use_puppeteer}"

    case content_type
    when %r{text/html}
      if !use_puppeteer
        Readability::Document.new(response.body).content
      else
        content = nil
        Puppeteer.launch(headless: true, args: ["--enable-javascript"]) do |browser|
          page = browser.pages.first || browser.new_page
          user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
          page.user_agent = user_agent
          response = page.goto(url)
          if response.status != 200
            puts "Failed to load page: #{response.status}"
            binding.pry # rubocop:disable Lint/Debugger
            return nil
          end
          page.wait_for_timeout(3000) # Wait for JavaScript to execute
          # page.wait_for_navigation(wait_until: "networkidle0")
          content = page.evaluate("() => document.body.innerHTML")
        end
        puts "content: #{content[0..500].inspect}"
        content = Readability::Document.new(content).content
      end
    when "application/pdf"
      file = URI.open(url)
      pdf = Poppler::Document.new(file.path)
      pdf.map do |page|
        page.get_text
      end.join("\n")
    end
  end

  def model
    # "gpt-4"
    # "gtp-4-turbo"
    "gpt-3.5-turbo"
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a summary
  def summarize_to_note(client:, alternative_url: nil, debug: false)
    sys_prompt = "Given the title, the link and other information from a source, concisely summarize and describe the contents of the URI using the following information.  Depending on if this is a video, url, or playlist, website, etc. refer to it appropriately.  Only summarize and describe the content given for an expert.  If there is not enough information to make a decision, return 'unknown'."

    if link.include?("youtube.com")
      puts Pastel.new.red.bold("Youtube link detected, extracting description.")

      # if it's a youtube live link, extract the id
      uri = URI.parse(alternative_url || link)
      if uri.path.include?("/live")
        yt_id = uri.path.split("/").last
        parsed_url = {"v" => [yt_id]}
      else
        parsed_url = CGI.parse(URI.parse(link).query)
      end
      if parsed_url["v"].first
        yt_id = parsed_url["v"].first
        video = Yt::Video.new id: yt_id
        # have the LLM summarize the description
        prompt = "Summarize the following youtube description, refer to it as 'This video'.  Also reference the channel name, '#{video.channel_title}'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{video.title}\ncategory: #{video.category_title}\ntags: #{video.tags.join(", ")}\ndescription: #{video.description}"
      elsif parsed_url["list"].first
        yt_id = parsed_url["list"].first
        playlist = Yt::Playlist.new id: yt_id
        prompt = "Summarize the following youtube playlist, refer to it as 'This youtube playlist'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{playlist.title}\ndescription: #{playlist.description}"
      else
        puts "No video id found in url, skipping."
        binding.pry # rubocop:disable Lint/Debugger
      end
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      self.note = response.dig("choices", 0, "message", "content")
    else # parse website
      uri = URI.parse(alternative_url || link)
      content = scrape_url(uri.to_s, debug: debug)
      # truncate content to keep it under 3000 characters
      binding.pry if content.nil? # rubocop:disable Lint/Debugger
      content = content[0..3000] if content.size > 3000
      puts "DEBUG: content: #{content[0..500].inspect}" if debug
      puts Pastel.new.yellow("Scraped content: #{content[0..500].inspect}")
    end

    prompt = if content
      "Summarize the following content, refer to it as best you can, it might be a blog, weekly newsletter, a news site, an article, a github repo, etc.  Try to be concise and specific as you can, for an expert. if it is a github repo, do not mention getting an account to contribute.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\n#{content}"
    else
      "title: #{title}\nurl: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\n"
    end
    binding.pry if debug # rubocop:disable Lint/Debugger
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    self.note = response.dig("choices", 0, "message", "content")
  end

  # @todo:
  # retag existing bookmarks
  def retag(raindrops)
    # load the current tags
    # use a prompt to parse and generate new tags based on more stringent criteria
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a set of tags
  def tag(client:)
    sys_prompt = "Given the title, the link and other information from a bookmark, generate a set of tags for the following text.  however, strive to keep the number of tags to a minimum, if there are multiple tags within the same area, chose a tag that cover the most, to keep the number of tags down. Do not generate empty, overly broad or meaningless tags that do not help find the content of this bookmark. for multi-word tags, use dashes between words.  e.g. Ruby-on-Rails, vs Ruby on Rails, or Visual-Studio-Code vs Visual Studio Code, as the tagging system is word based.  If there is not enough information to make a decision, return 'unknown'."
    prompt = "#{title}\n#{link}\n#{excerpt}\n#{note}\n#{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    incoming_tag = response.dig("choices", 0, "message", "content").split.map { |i| i.delete("#").delete(",").strip }
    self.tags = incoming_tag.reject { |i| i =~ /^\p{Punct}$/ || i == "" }.compact
  end

  def pick_category(client:, collections:)
    cleaned_collections = collections.map(&:title).compact.reject { |i| i == "" || i == "Unread" }
    sys_prompt = "Given the title, the link and other information from a bookmark, categorize the following text into one of the following categories: #{cleaned_collections.join(", ")}\nRespond with ONLY the category from the list above, with no extra formatting or words.  If none apply, use 'unknown'."
    prompt = "title: #{title}\nlink: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\ndomain: #{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    collection_title = response.dig("choices", 0, "message", "content")
    if /unknown/i.match?(collection_title)
      # ask if a new collection should be created
      sys_prompt = "This does not currently fit any of the existing categories (#{cleaned_collections.join(", ")}).  Suggest a new category this bookmark can be filed under.  Respond with only the proposed category, it should be short, without any spaces or punctuation, with only dashes to separate words if necessary."
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      proposed_collection_title = response.dig("choices", 0, "message", "content")
      puts "Proposed collection title: #{proposed_collection_title}, use it to create a new collection? (yes/no)"
      answer = $stdin.gets.chomp
      if answer == "yes"
        col = RaindropIo::Collection.create!(title: proposed_collection_title)
        Collection.create!(title: proposed_collection_title)
        return col
      else
        puts "No new collection created, dropping into debugger"
        binding.pry # rubocop:disable Lint/Debugger
      end
    end
    col = Collection.find_by(title: collection_title)
    if col.nil?
      # create new collection
      attrs = {
        title: collection_title,
        public: false
        # parent: {"$ref" => "collections", "$id" => parent_id, "oid" => parent_id}
      }
      puts "we are here in this exception because collection_title is #{collection_title}"
      # we can either give choices to existing collectioons, or create a new one
      col = RaindropIo::Collection.create!(attrs)
      binding.pry # rubocop:disable Lint/Debugger
    end
    col
  end

  def move_to_collection(target_collection)
    self.collectionId = target_collection._id
    self.collection = {"$ref" => "collections", "$id" => collectionId, "oid" => collectionId}
    puts "Moving to collection: #{Pastel.new.green.bold(target_collection.title)} (#{collection.inspect})!"
  end

  def suggest
    RaindropIo::Raindrop.suggest(_id)
  end

  def pull_data
  end

  def push_data!
    # update the raindrop with the new data
    resp = RaindropIo::Raindrop.update(_id, data: attributes.except(:id, "id"))
    if resp.is_a?(RaindropIo::Raindrop)
      puts Pastel.new.green("Successfully updated raindrop, #{resp.attributes["title"]}")
      # assign attributes from the resposne raindrop to the current and save
      resp.attributes.each do |k, v|
        if has_attribute?(k)
          self[k] = v
        else
          self[:extra_data][k] = v
        end
      rescue
        puts "Failed to assign #{k} to #{v}"
        raise
      end
      save!
    else
      puts "Failed to update raindrop. #{resp.inspect}"
    end
  end
end

class User < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    ActiveRecord::Schema.define do
      unless table_exists?(:users)
        create_table :users do |t|
          t.integer :_id
          t.jsonb :data, null: false, default: {}
        end
      end # unless
    end # Schema.define
  end
end

class DBHandler
  attr_accessor :db_type

  def initialize(db_type)
    @db_type = db_type.to_s
    raise "Invalid db_type" unless @db_type == "postgres" || @db_type == "sqlite3"
  end

  def db_config
    (db_type == "postgres") ? postgres_config : sqlite3_config
  end

  def sqlite3_config
    {adapter: "sqlite3", database: "raindrop_io.db"}
  end

  def postgres_config
    # username: "", # password: "your_password",
    {adapter: "postgresql", database: "raindrop", encoding: "unicode", host: "localhost"}
  end

  def connect
    # File.exist?("raindrop_io.db")
    ActiveRecord::Base.establish_connection(db_config)
    # the database needs to exist already, can't figure out how to create it from here
    ActiveRecord::Base.connection
  rescue => e
    puts "WARNING: error connecting to db. #{e}"
    # ActiveRecord::Base.establish_connection(config.merge("database" => "postgres"))
    # ActiveRecord::Base.connection.create_database(config["database"], config)
    # ActiveRecord::Base.establish_connection(config)
  end

  def migrate!
    Collection.do_migration
    Raindrop.do_migration
    User.do_migration
  end

  def drop!
    tables = %w[collections raindrops users]
    tables.each do |table|
      ActiveRecord::Base.connection.drop_table table if ActiveRecord::Base.connection.table_exists? table
    end
  end

  def dump_to_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end

  def load_from_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end
end

class Processor
  attr_accessor :command, :logger, :db, :openai_client, :pastel

  def initialize(command)
    @db = DBHandler.new(:postgres)
    @db.connect
    # ActiveRecord::Base.establish_connection(@db.db_config)
    @logger = $logger # rubocop:disable Style/GlobalVars
    @openai_client = OpenAI::Client.new(access_token: ENV["OPENAI_API_KEY"])
    @pastel = Pastel.new
  end

  def self.load_all_raindrops_in_col(col_id, delay: 2)
    rv = []
    drops = RaindropIo::Raindrop.raindrops(col_id)
    total_pages = drops[:total] / RaindropIo::Raindrop.default_page_size
    if drops[:total] > 0 && total_pages == 0
      total_pages = 1
    end
    (0...total_pages).each do |page|
      drops = RaindropIo::Raindrop.raindrops(col_id, page: page)
      sleep_counter = 0

      drops[:items].each do |drop|
        if Raindrop.where(_id: drop._id).empty? # avoid dupes
          column_names = ::Raindrop.column_names
          data = drop.to_hash
          # Separate the data into known and extra attributes, since things change
          known_attrs = data.select { |k, v| column_names.include?(k) }
          unknown_attrs = data.except(*column_names)
          known_attrs["extra_data"] = unknown_attrs
          drop = Raindrop.create!(known_attrs)
          rv << drop
          ap drop.as_json
          sleep_counter += 1
          if sleep_counter % 10 == 0
            puts "Sleeping for #{delay} seconds"
            sleep delay
          end
        else
          puts "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
          logger.debug "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
        end
      end
      ap "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
      logger.debug "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
    end
    rv
  end

  def self.load_all_collections(delay: 2)
    collections = RaindropIo::Collection.all
    # is there paging?  how do I get everything including their children?
    collections.each do |col|
      if Collection.where(_id: col._id).empty?
        column_names = Collection.column_names
        data = col.to_hash
        known_attrs = data.select { |k, v| column_names.include?(k) }
        unknown_attrs = data.except(*column_names)
        known_attrs["extra_data"] = unknown_attrs
        Collection.create!(known_attrs)
        # sleep delay
      else
        puts "Duplicate collection, skipping _id: #{col._id} #{col.title}"
        # logger.debug "Duplicate collection, skipping _id: #{col._id} #{col.title}"
      end
    end
    Collection.all.map { |col| [col._id, col.title] }
  end

  # todo load collections and arrange them in a tree format

  def load_user
    user = RaindropIo::User.current_user
    if User.where(_id: user._id).empty?
      User.create!(_id: user._id, data: user.to_hash)
    end
  end

  def categorize_drops
    prompt = TTY::Prompt.new
    uncategorized_drops = Raindrop.where("collection ->> 'oid' = ?", "-1")
    n = 0
    uncategorized_drops.each do |drop|
      n += 1
      puts "\n\n\n\n(#{n}/#{uncategorized_drops.size}, #{uncategorized_drops.size - n} left) id: #{drop.id} #{pastel.yellow.bold(drop.title)} - #{drop.link}"

      drop.summarize_to_note(client: openai_client)
      drop.tag(client: openai_client)
      puts "tags: #{drop.tags.map { |t| pastel.cyan.bold(t) }.join(", ")}\n"
      target_collection = drop.pick_category(client: @openai_client, collections: Collection.all)
      if target_collection.nil?
        puts pastel.red("No target collection found for #{drop.title}\nDrop id: #{drop.id}/#{drop._id}  #{pastel.bold(drop.title)}")
        binding.pry # rubocop:disable Lint/Debugger
        next
      end
      puts "drop.note: #{pastel.red.bold(drop.note)}\n"
      drop.move_to_collection(target_collection)
      puts "\n"

      print "Contine [enter], (r)eload collections, (u)se different url, (m)ove to another collection, (f)ix summary, (d)ebug, dele(t)e drop - for later recat, (q)uit : "

      # design notes:
      #  * need to adjust tags
      #  * change category
      #  * change summary, maybe the url is not giving useful info
      #  * there might be tags or keywords that push to a category that we need to remember
      #  * a way to create new tags and categories, and push past and future categorizations to them
      #  TODO: maybe add descriptions to categories to help guide further refinements to the llm categorization
      # categorization based on past categorizations?
      ans = $stdin.gets.chomp
      case ans
      when "d"
        binding.pry # rubocop:disable Lint/Debugger
        next
      when "q"
        exit 0
      when "r"
        self.class.load_all_collections
        break
      when "t"
        drop.destroy
        next
      when "m"
        all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }.sort
        new_category = prompt.select("Select a category", all_categories, per_page: 20)
        target_collection = Collection.find_by(title: new_category)
        drop.move_to_collection(target_collection)
        drop.save!
      when "u"
        new_url = prompt.ask("Enter new url: ")
        drop.summarize_to_note(client: openai_client, alternative_url: new_url)
        drop.tag(client: openai_client)
        puts "new drop.note: #{pastel.red.bold(drop.note)}\n"
        if prompt.yes?("use new summary?")
          all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }
          new_category = prompt.select("Select a category", all_categories, per_page: 20)
          target_collection = Collection.find_by(title: new_category)
          drop.move_to_collection(target_collection)
          puts "saving..."
          drop.save!
        else
          puts "exiting.."
          exit 1
        end
      when "f"
        puts "Current note: #{drop.id}/#{drop._id} #{drop.link} \n#{drop.note}"
        ans = prompt.select("Edit current drop, or load another by _id?", %w[edit load])
        if ans == "load"
          print "Enter id: "
          id = $stdin.gets.chomp
          drop = Raindrop.find_by(_id: id)
        end
        binding.pry # rubocop:disable Lint/Debugger
        drop.save!
      when ""
        puts "processing...\n"
      else
        puts "unknown command #{ans.inspect}\n\n"
        binding.pry # rubocop:disable Lint/Debugger
        break
      end

      drop.save!
      # ask to continue, or change the target collection
      # if prompt.select("Continue or change target collection?", %w[continue change]) == "change"
      #   all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }
      #   new_category = prompt.select("Select a category", all_categories, per_page: 20)
      #   target_collection = Collection.find_by(title: new_category)
      #   drop.move_to_collection(target_collection)
      #   drop.save!
      # end
      drop.push_data!
      puts "Updated remote with title: #{pastel.yellow(drop.title)}\n#{pastel.red.bold(drop.note)}\n#{drop.tags.map { |t| pastel.cyan(t) }.join(", ")}\n"
    end
  end

  def uncategorized_drops
    rel = Raindrop.where("collection ->> 'oid' = ?", "-1")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def drops_without_notes
    rel = Raindrop.where("note IS NULL or note = ''")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def drops_withou_tags
    rel = Raindrop.where("tags IS NULL or tags = '[]'")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def main
    loop do
      prompt = TTY::Prompt.new
      puts pastel.yellow.bold("\n\nNote that load is an action that loads from the remote API, and list is an action that lists the local database.\n\n")
      action = prompt.select("Choose an action", enum: ".", per_page: 30, cycle: true) do |menu|
        menu.choice "repl"
        menu.choice "load raindrops"
        menu.choice "list raindrops"
        menu.choice "load collections"
        menu.choice "list collections"
        menu.choice "categorize drops"
        menu.choice "show user"
        menu.choice "exit"
      end

      case action
      when "repl"
        %w[uncategorized_drops drops_without_notes drops_withou_tags].each do |method|
          puts pastel.green.bold("#{method}.each { |drop| } ")
        end
        binding.pry # rubocop:disable Lint/Debugger
      when "load raindrops"
        drops = self.class.load_all_raindrops_in_col(-1)
        binding.pry # rubocop:disable Lint/Debugger
      when "list raindrops"
        raindrops = Raindrop.all
        pager = TTY::Pager.new
        pager.page(raindrops.as_json.ai)
        binding.pry # rubocop:disable Lint/Debugger
      when "load collections"
        collections = self.class.load_all_collections
        ap collections
        binding.pry # rubocop:disable Lint/Debugger
      when "list collections"
        collections = Collection.all
        pager = TTY::Pager.new
        pager.page(collections.as_json.ai)
        puts collections.map { |c| "c.id: #{c.id}, c._id: #{c._id}, c.title: #{c.title}" }.join("\n")
        # TODO, generate the collections in the nested format, and display them in a tree format
        binding.pry # rubocop:disable Lint/Debugger
      when "categorize drops"
        categorize_drops
      when "show user"
        cur_user = RaindropIo::User.current_user
        ap cur_user
        binding.pry # rubocop:disable Lint/Debugger
      when "exit"
        exit 0
      else
        puts "Unknown action: #{action}"
      end # case
    end # loop
  end # main
end # Processor

processor = Processor.new(command)
processor.main
