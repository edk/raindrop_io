#!/usr/bin/env ruby

require_relative "../lib/raindrop_io"
require "dotenv/load"
require "optparse"
require "json"
require "logger"
require "awesome_print"
require "sqlite3"
require "pg"
require "active_record"
require "openai"
require "tty-prompt"
require "tty-table"
require "tty-tree"
require "tty-pager"
require "pastel"
require "readability"
require "poppler"
require "net/http"
require "uri"
require "open-uri"
require "puppeteer-ruby"
require "cgi"
require "yt"

class Command
  attr_accessor :command, :object, :options, :token

  def initialize(args)
    if !File.exist?(".env")
      usage
    end
    keys = %w[RAINDROP_TOKEN OPENAI_API_KEY YOUTUBE_API_KEY]
    missing = []
    keys.each do |key|
      missing << key unless ENV[key].to_s.size > 0
    end
    if missing.any?
      warn "Missing required environment variables: #{missing.join(", ")}\n\n"
      usage
    end
  end

  def usage
    warn "Usage: #{$0}\n\n"
    warn " Set required variables in .env file\n"
    warn "  RAINDROP_API_TOKEN=your_token\n"
    warn "  OPENAI_API_KEY=your_key\n"
    warn "  YOUTUBE_API_KEY=your_key\n"
    exit 1
  end
end

command = Command.new(ARGV)
Yt.configure do |config|
  config.log_level = :debug
  config.api_key = ENV["YOUTUBE_API_KEY"]
end

$logger = Logger.new("raindrop_io.log") # rubocop:disable Style/GlobalVars
$logger.level = Logger::DEBUG # rubocop:disable Style/GlobalVars

RaindropIo::Api.configure do |config|
  config.api_token = ENV["RAINDROP_TOKEN"]
  config.logger = $logger # rubocop:disable Style/GlobalVars
end

class SkipRaindrop < StandardError; end

class DeleteRaindrop < StandardError; end

class Collection < ActiveRecord::Base
  self.inheritance_column = nil

  # references to other collections are via _id not id
  def children
    Collection.where("CAST(parent ->> '$id' AS INTEGER) = ?", _id)
  end

  # the parent link is a json object with $id and $ref keys.  the "$id" is the _id of the parent collection
  def parent_link
    parent_id = parent && parent["$id"]
    Collection.find_by(_id: parent_id)
  end

  def parents_chain
    parents_chain = []
    current_node = self
    while current_node.parent_link.present?
      parents_chain << current_node.parent_link
      current_node = current_node.parent_link
    end
    parents_chain.reverse
  end

  def self.roots
    Collection.where(parent: nil)
  end

  def print_with_full_path
    [parents_chain.map(&:title).compact << title].compact.join(" > ")
  end

  def self.test
    leafs = leaf_nodes
    leafs.each do |leaf|
      parents = leaf.parents_chain.map(&:title).reject { |i| i == "" }
      line = parents << leaf.title
      puts line.join(" > ")
    end
  end

  def self.leaf_nodes
    all.reject { |c| c.children.count > 0 }
  end

  def self.do_migration
    collection_attrs = {
      int_fields: %w[_id count sort parent_link_id],
      string_fields: %w[color created lastUpdate title view description],
      bool_fields: %w[expanded public],
      object_fields: %w[access collaborators cover parent user creatorRef],
      extra_fields: %w[broken cache file important highlights lastAction slug author extra_data]
    }
    ActiveRecord::Schema.define do
      if table_exists?(:collections)
        drop_table :collections
      end
      unless table_exists?(:collections)
        create_table :collections do |t|
          attrs = collection_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end
    end
  end

  def self.get_children(parent)
    data = {}
    parent.children.each do |child|
      data["#{child.id} #{child.title}"] = get_children(child)
    end
    data
  end

  def self.get_tree
    data = {}
    Collection.roots.each do |node|
      data["#{node._id} #{node.title}"] = get_children(node)
    end
    TTY::Tree.new(data)
  end

  def remove!
    RaindropIo::Collection.remove(_id)
  end
end

# | \_id             | `Integer`       | The id of the collection.
# | access           | `Object`
# | access.level     | `Integer`       | 1.  read only access (equal to `public=true`)  2.  collaborator with read only access  3.  collaborator with write only access  4.  owner
# | access.draggable | `Boolean`       | Does it possible to change parent of this collection?
# | collaborators    | `Object`        | When this object is present, means that collections is shared. Content of this object is private and not very useful. All sharing API methods [described here](https://developer.raindrop.io/v1/collections/sharing) |
# | color            | `String`        | Primary color of collection cover as `HEX`
# | count            | `Integer`       | Count of raindrops in collection
# | cover            | `Array<String>` | Collection cover URL. This array always have one item due to legacy reasons
# | created          | `String`        | When collection is created
# | expanded         | `Boolean`       | Whether the collectionâ€™s sub-collections are expanded
# | lastUpdate       | `String`        | When collection is updated
# | parent           | `Object`
# | parent.$id       | `Integer`       | The id of the parent collection. Not specified for root collections
# | public           | `Boolean`       | Collection and raindrops that it contains will be accessible without authentication by public link
# | sort             | `Integer`       | The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
# | title            | `String`        | Name of the collection
# | user             | `Object`
# | user.$id         | `Integer`       | Owner ID
# | view             | `String`        | View style of collection, can be:*   `list` (default) `simple` `grid` `masonry` Pinterest like grid
class Raindrop < ActiveRecord::Base
  self.inheritance_column = nil

  def remove!
    RaindropIo::Raindrop.remove(_id)
  end

  def self.do_migration
    raindrop_attrs = {
      int_fields: %w[_id count sort collectionId],
      string_fields: %w[color created domain excerpt note cover lastUpdate title type view link],
      bool_fields: %w[broken expanded public important removed],
      object_fields: %w[collection media tags collaborators parent user creatorRef cache file highlights reminder],
      extra_fields: %w[extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:raindrops)
        create_table :raindrops do |t|
          attrs = raindrop_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end # unless
    end
  end

  def collection_link
    Collection.find_by(_id: collectionId)
  end

  def resolve_uri(base_uri, new_location)
    new_location.tr!("\\", "/")
    return URI(new_location) if new_location.start_with?("http")
    URI.join(base_uri, new_location)
  end

  def fetch_uri(uri, limit: 10)
    raise ArgumentError, "HTTP redirect too deep" if limit.zero?

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == "https"
    request = Net::HTTP::Get.new(uri.request_uri)
    request["User-Agent"] = ["Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"]

    begin
      response = http.request(request)
    rescue Net::OpenTimeout, Net::ReadTimeout
      puts pastel.red("Timeout fetching #{uri}")
      raise
    end

    case response
    when Net::HTTPSuccess
      response
    when Net::HTTPRedirection
      fetch_uri(resolve_uri(uri, response["location"]), limit: limit - 1)
    else
      response
    end
  end

  def user_agent
    # "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:125.0) Gecko/20100101 Firefox/125.0"
  end

  def prompt
    TTY::Prompt.new
  end

  def pastel
    Pastel.new
  end

  def parse_metadata_from_html(html)
    doc = Nokogiri::HTML(html)
    title = doc.at_css("title").text
    description = doc.at_css("meta[name='description']")&.attr("content")
    keywords = doc.at_css("meta[name='keywords']")&.attr("content")
    author = doc.at_css("meta[name='author']")&.attr("content")
    date = doc.at_css("meta[name='date']")&.attr("content")
    {title: title, description: description, keywords: keywords, author: author, date: date}
  end

  def scrape_url(url, debug: false, force_html: false)
    source_url = URI.parse(url)

    begin
      response = fetch_uri(source_url)
    rescue OpenSSL::SSL::SSLError
      puts "SSL error: #{url}"
      if prompt.yes?("Skip this raindrop?")
        raise SkipRaindrop.new("SSL error: #{url}")
      end
      if prompt.yes?("Delete this drop?")
        raise DeleteRaindrop.new("SSL error: #{url} removed and destroyed drop")
      end
    rescue Net::OpenTimeout, Net::ReadTimeout
      force_html = true # rubocop:disable Lint/ShadowedArgument
    end

    content_type = response["content-type"] if response

    if force_html
      use_headless_browser = true
      content_type = "text/html"
    elsif /forbidden/i.match?(response.message) ||
        /You need to enable JavaScript/i.match?(response.body)
      puts "DEBUG: response.message: #{response.message}"
      use_headless_browser = true
      force_html = true
      content_type = "text/html"
    else
      use_headless_browser = false
      force_html = false
    end
    puts "DEBUG: content_type: #{content_type} force_html: #{force_html} use_headless_browser: #{use_headless_browser}"

    case content_type
    when %r{text/html}
      if !use_headless_browser
        begin
          Readability::Document.new(response.body, encoding: "UTF-8").content
        rescue
          binding.pry
        end
      else
        content = nil
        puppeteer_args = [
          "--enable-javascript",
          "--no-sandbox",
          "--disable-setuid-sandbox",
          "--user-agent='#{user_agent}'"
        ]
        Puppeteer.launch(headless: true, args: puppeteer_args) do |browser|
          page = browser.new_page
          page.viewport = Puppeteer::Viewport.new(width: 1301, height: 823)
          page.user_agent = user_agent

          # look for cookie files under ./cookies that match the domain
          uri = URI.parse(url)
          cookie_file = File.join("cookies", "#{uri.host}.json")
          if File.exist?(cookie_file)
            puts "Loading cookies from file: #{cookie_file}"
            raw_cookies = JSON.parse(File.read(cookie_file))
            cookies = raw_cookies.map do |raw_cookie|
              # Map the raw cookie format to the expected format
              {
                name: raw_cookie["Name raw"],
                value: raw_cookie["Content raw"],
                domain: uri.host,  # Setting domain to the URI's host
                path: raw_cookie["Path raw"] || "/",
                expires: raw_cookie["Expires raw"] ? Integer(raw_cookie["Expires raw"]) : nil,
                http_only: raw_cookie["HTTP only raw"] == "true",
                secure: raw_cookie["Send for raw"] == "true",
                same_site: raw_cookie["SameSite raw"].to_s.downcase
              }.compact  # This removes any nil values that might break Puppeteer's set_cookie
            end

            cookies.each do |cookie|
              # puts "Setting cookie: #{cookie}"
              page.set_cookie(cookie)
            end
          else
            puts "No cookie file found for #{uri.host}"
          end

          begin
            response = page.goto(url, wait_until: "networkidle0")
          rescue Puppeteer::FrameManager::NavigationError
            puts "DEBUG: Failed to load page, retrying with domcontentloaded"
            begin
              response = page.goto(url, wait_until: "domcontentloaded")
            rescue => e
              puts "Failed to load page: #{e.message}"
              if prompt.yes?("Failed to load page: #{e.message} - #{id} #{url}.  destroy?")
                remove!
                destroy
                raise SkipRaindrop.new("Failed to load page: #{e.message} removed and destroyed drop")
              end
              binding.pry # rubocop:disable Lint/Debugger
            end
          end
          if response.status == 404
            puts "Failed to load page: #{response.status}"
            raise SkipRaindrop.new("404 error - #{id} #{url}")
          elsif response.status == 401
            puts "Failed to load page: #{response.status}"
            raise SkipRaindrop.new("401 error - #{id} #{url}")
          elsif response.status != 200
            puts "Failed to load page: #{response.status}"
            if prompt.yes?("Failed to load page: #{response.status} - #{id} #{url}.  destroy?")
              remove! && destroy!
              raise SkipRaindrop.new("Failed to load page: #{response.status} - #{id} #{url}")
            end
            if prompt.yes?("Mark to skip?")
              raise SkipRaindrop.new("Failed to load page: #{response.status} - #{id} #{url}")
            end
            binding.pry # rubocop:disable Lint/Debugger
            return nil
          end
          # page.wait_for_timeout(3000) # Wait for JavaScript to execute
          # page.wait_for_navigation(wait_until: "networkidle0")
          content = page.evaluate("() => document.body.innerText")
          binding.pry if debug # rubocop:disable Lint/Debugger
        end
        content = Readability::Document.new(content).content.squish
      end
    when "application/pdf"
      uri = URI(url)
      file = Tempfile.new("download", encoding: "ascii-8bit")
      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == "https") do |http|
        request = Net::HTTP::Get.new uri
        http.request request do |response|
          response.read_body do |chunk|
            file.write chunk
          end
        end
      end
      file.rewind

      pdf = Poppler::Document.new(file.path)
      file.close
      file.unlink
      pdf.map do |page|
        page.get_text
      end.join("\n")
    end
  end

  def model
    # "gpt-4"
    # "gtp-4-turbo"
    "gpt-3.5-turbo"
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a summary
  def summarize_to_note(client:, alternative_url: nil, debug: false, force_html: false)
    sys_prompt = "Given the title, the link and other information from a source, concisely summarize and describe the contents of the URI using the following information.  Depending on if this is a video, url, or playlist, website, etc. refer to it appropriately.  Only summarize and describe the content given for an expert.  If there is not enough information to make a decision, return 'unknown'."
    sys_prompt = "Given the title, link, and other details from a source, describe the contents of the URI concisely and directly. Label the source type (e.g., video, website, blog, GitHub repo) and summarize the main points tailored for an expert audience. If information is insufficient to categorize or summarize, respond with 'unknown.' Avoid general phrases such as 'This content' or 'The content.' Ensure brevity as this will be used in a bookmark management system."

    if link.include?("youtube.com") || link.include?("youtu.be")
      puts pastel.red.bold("Youtube link detected, extracting description.")

      # if it's a youtube live link, extract the id
      uri = URI.parse(alternative_url || link)
      if link.include?("youtu.be")
        yt_id = uri.path.split("/").last
        parsed_url = {"v" => [yt_id]}
      elsif uri.path.include?("/live")
        yt_id = uri.path.split("/").last
        parsed_url = {"v" => [yt_id]}
      else
        parsed_url = CGI.parse(URI.parse(link).query)
      end
      if parsed_url["v"].first
        yt_id = parsed_url["v"].first
        video = Yt::Video.new id: yt_id
        # have the LLM summarize the description
        prompt = "Summarize the following youtube description, refer to it as 'This video'.  Also reference the channel name, '#{video.channel_title}'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{video.title}\ncategory: #{video.category_title}\ntags: #{video.tags.join(", ")}\ndescription: #{video.description}"
      elsif parsed_url["list"].first
        yt_id = parsed_url["list"].first
        playlist = Yt::Playlist.new id: yt_id
        prompt = "Summarize the following youtube playlist, refer to it as 'This youtube playlist'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{playlist.title}\ndescription: #{playlist.description}"
      else
        puts "No video id found in url, skipping."
        binding.pry # rubocop:disable Lint/Debugger
      end
      puts "DEBUG: prompt: #{prompt}" if debug
      binding.pry if debug # rubocop:disable Lint/Debugger
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      self.note = response.dig("choices", 0, "message", "content")
    else # parse website
      uri = URI.parse(alternative_url || link)
      if /github.com/.match?(uri.host)
        puts pastel.red.bold("Github link detected.  forcing headless browser with cookies.")
        force_html = true
      end
      content = scrape_url(uri.to_s, debug: debug, force_html: force_html)
      # truncate content to keep it under 3000 characters
      binding.pry if content.nil? || debug # rubocop:disable Lint/Debugger
      content = content[0..3000] if content.size > 3000
      puts "DEBUG: content: #{content[0..500].inspect}" if debug
      puts pastel.yellow("Scraped content: #{content[0..500].inspect}")
    end

    prompt = if content
      "Describe the provided content directly, identifying it as a blog, newsletter, news site, article, GitHub repo, etc. Summarize the key points succinctly for an expert reader. Exclude instructions like creating an account for contributions in the case of GitHub repos. Aim for a brief, precise description suitable for the notes column in a bookmarks table.\n\n#{content}"
    else
      "title: #{title}\nurl: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\n"
    end
    binding.pry if debug # rubocop:disable Lint/Debugger
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    self.note = response.dig("choices", 0, "message", "content")
  end

  def process!(client:, debug: false)
    puts pastel.yellow.bold("Processing raindrop #{id} - #{title}\nlink: #{pastel.red.bold(link)}")
    summarize_to_note(client: client, debug: debug)
    if /unknown/i.match?(note)
      puts "note is unknown, retrying with browser"
      summarize_to_note(client: client, force_html: true)
    end
    puts "note: #{note}"
    tag(client: client)
    puts "tags: #{pastel.green.bold(tags.join(", "))}"
    target_collection = pick_category(client: client, collections: Collection.all)
    move_to_collection(target_collection)
    push_data!
    save!
  end

  # @todo:
  # retag existing bookmarks
  def retag(raindrops)
    # load the current tags
    # use a prompt to parse and generate new tags based on more stringent criteria
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a set of tags
  def tag(client:)
    sys_prompt = "Given the title, the link and other information from a bookmark, generate a set of tags using the following text.  Keep the number of tags to a minimum, if there are multiple tags within the same area, chose a tag that cover the most. Do not generate empty, overly broad or meaningless tags that do not help find the content of this bookmark. for multi-word tags, use dashes between words.  e.g. Ruby-on-Rails, vs Ruby on Rails, or Visual-Studio-Code vs Visual Studio Code, as the tagging system is word based.  If there is not enough information to make a decision, return 'unknown'."
    prompt = "#{title}\n#{link}\n#{excerpt}\n#{note}\n#{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    incoming_tag = response.dig("choices", 0, "message", "content").split.map { |i| i.delete("#").delete(",").strip }
    self.tags = incoming_tag.reject { |i| i =~ /^\p{Punct}$/ || i == "" }.compact
  end

  def pick_category(client:, collections:, ask_user_input: false)
    cleaned_collections = collections.reject { |c| ["Unread", "Trash", "Unsorted"].include?(c.title) }
      .map { |c| c.print_with_full_path }.sort

    sys_prompt = "You are an expert in categorizing and understanding how to organize bookmarks.  Given the title, the link and other metadata from a bookmark, you can categorize text into one of the following categories.  The categories are hierarchical and the right-most category is the most specific.:\n\n" \
    "#{cleaned_collections.join("\n")}\n\n" \
    "Respond with ONLY the category from the list above, using the rightmost word for the category, with no extra formatting or words.  If none apply, use 'unknown'."
    prompt = "Categorize based on the following:\ntitle: #{title}\nlink: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\ndomain: #{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    collection_title = response.dig("choices", 0, "message", "content")
    puts "DEBUG: collection_title: #{pastel.green.bold(collection_title)}"
    if /unknown/i.match?(collection_title)
      # ask if a new collection should be created
      sys_prompt = "This does not currently fit any of the existing categories (#{cleaned_collections.join("\n")}).  Suggest a new category this bookmark can be filed under.  Respond with only the proposed category, it should be short, without any spaces or punctuation, with only dashes to separate words if necessary."
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      ask_user_input = true
    end
    if ask_user_input
      proposed_collection_title = response.dig("choices", 0, "message", "content")
      prompt = TTY::Prompt.new
      choices = [
        {name: "Select different category", value: "select"},
        {name: "Create new collection (#{proposed_collection_title})", value: "new"},
        {name: "Delete raindrop (#{title})", value: "delete"},
        {name: "Skip picking a collection", value: "skip"},
        {name: "Debug", value: "debug"}
      ]
      answer = prompt.select("What would you like to do?", choices, cycle: true, per_page: 15)
      case answer
      when "new"
        # creates a new collection at the base.  should we handle sub-collections?
        col = RaindropIo::Collection.create!(title: proposed_collection_title)
        c = Collection.new(col.attributes)
        c.save!
      when "select"
        # prompt to select a different category
        categories = cleaned_collections
        selected_collection = prompt.select("Select a category", categories, per_page: 50)
        if prompt.yes?("You selected: #{selected_collection}.  Press enter to continue.")
          collection_title = selected_collection
          # we then continue, fall out of this block, and the Collection.find_by below will set the collection
        end
      when "delete"
        remove!
        destroy!
      when "skip"
        return nil
      when "debug"
        binding.pry # rubocop:disable Lint/Debugger
      end
    end
    # split the collection_title to grab the last word
    collection_title = collection_title.split(">").last.strip
    col = Collection.find_by(title: collection_title)
    if col.nil?
      # create new collection
      attrs = {
        title: collection_title,
        public: false
        # parent: {"$ref" => "collections", "$id" => parent_id, "oid" => parent_id}
      }
      puts "we are here in this exception because collection_title is #{collection_title}"
      prompt = TTY::Prompt.new
      if prompt.yes?("Create new collection: #{collection_title}")
        col = RaindropIo::Collection.create!(attrs)
        c = Collection.new(col.attributes)
        c.save!
      elsif prompt.yes?("Use a different category?")
        categories = cleaned_collections
        selected_collection = prompt.select("Select a category", categories, per_page: 50)
        if prompt.yes?("You selected: #{selected_collection}.  Press enter to continue.")
          col = Collection.find_by(title: selected_collection.split(">").last.strip)
          return col
        end
      end
    end
    col
  end

  def move_to_collection(target_collection)
    self.collectionId = target_collection._id
    self.collection = {"$ref" => "collections", "$id" => collectionId, "oid" => collectionId}
    puts "Moving to collection: #{pastel.green.bold(target_collection.title)} (#{collection.inspect})!"
  end

  def suggest
    RaindropIo::Raindrop.suggest(_id)
  end

  def pull_data
  end

  def push_data!
    # update the raindrop with the new data
    resp = RaindropIo::Raindrop.update(_id, data: attributes.except(:id, "id"))
    if resp.is_a?(RaindropIo::Raindrop)
      puts pastel.green("Successfully updated raindrop, #{resp.attributes["title"]}")
      # assign attributes from the resposne raindrop to the current and save
      resp.attributes.each do |k, v|
        if has_attribute?(k)
          self[k] = v
        else
          self[:extra_data][k] = v
        end
      rescue
        puts "Failed to assign #{k} to #{v}"
        raise
      end
      save!
    else
      puts "Failed to update raindrop. #{resp.inspect}"
    end
  end
end

class User < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    ActiveRecord::Schema.define do
      unless table_exists?(:users)
        create_table :users do |t|
          t.integer :_id
          t.jsonb :data, null: false, default: {}
        end
      end # unless
    end # Schema.define
  end
end

class DBHandler
  attr_accessor :db_type

  def initialize(db_type)
    @db_type = db_type.to_s
    raise "Invalid db_type" unless @db_type == "postgres" || @db_type == "sqlite3"
  end

  def db_config
    (db_type == "postgres") ? postgres_config : sqlite3_config
  end

  def sqlite3_config
    {adapter: "sqlite3", database: "raindrop_io.db"}
  end

  def postgres_config
    # username: "", # password: "your_password",
    {adapter: "postgresql", database: "raindrop", encoding: "unicode", host: "localhost"}
  end

  def connect
    # File.exist?("raindrop_io.db")
    ActiveRecord::Base.establish_connection(db_config)
    # the database needs to exist already, can't figure out how to create it from here
    ActiveRecord::Base.connection
  rescue => e
    puts "WARNING: error connecting to db. #{e}"
    # ActiveRecord::Base.establish_connection(config.merge("database" => "postgres"))
    # ActiveRecord::Base.connection.create_database(config["database"], config)
    # ActiveRecord::Base.establish_connection(config)
  end

  def migrate!
    Collection.do_migration
    Raindrop.do_migration
    User.do_migration
  end

  def drop!
    tables = %w[collections raindrops users]
    tables.each do |table|
      ActiveRecord::Base.connection.drop_table table if ActiveRecord::Base.connection.table_exists? table
    end
  end

  def dump_to_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end

  def load_from_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end
end

class Processor
  attr_accessor :command, :logger, :db, :openai_client, :pastel

  def initialize(command)
    @db = DBHandler.new(:postgres)
    @db.connect
    # ActiveRecord::Base.establish_connection(@db.db_config)
    @logger = $logger # rubocop:disable Style/GlobalVars
    @openai_client = OpenAI::Client.new(access_token: ENV["OPENAI_API_KEY"])
    @pastel = Pastel.new
  end

  def self.load_all_raindrops_in_col(col_id, delay: 2)
    rv = []
    drops = RaindropIo::Raindrop.raindrops(col_id)
    total_pages = drops[:total] / RaindropIo::Raindrop.default_page_size
    if drops[:total] > 0 && total_pages == 0
      total_pages = 1
    end
    (0...total_pages).each do |page|
      drops = RaindropIo::Raindrop.raindrops(col_id, page: page)
      sleep_counter = 0

      drops[:items].each do |drop|
        if Raindrop.where(_id: drop._id).empty? # avoid dupes
          column_names = ::Raindrop.column_names
          data = drop.to_hash
          # Separate the data into known and extra attributes, since things change
          known_attrs = data.select { |k, v| column_names.include?(k) }
          unknown_attrs = data.except(*column_names)
          known_attrs["extra_data"] = unknown_attrs
          drop = Raindrop.create!(known_attrs)
          rv << drop
          ap drop.as_json
          sleep_counter += 1
          if sleep_counter % 10 == 0
            puts "Sleeping for #{delay} seconds"
            sleep delay
          end
        else
          puts "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
          $logger.debug "Duplicate link, skipping _id: #{drop._id} #{drop.link}" # rubocop:disable Style/GlobalVars
        end
      end
      ap "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
      $logger.debug "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}" # rubocop:disable Style/GlobalVars
    end
    rv
  end

  def self.handle_blank_titles(known_attrs)
    case known_attrs["_id"]
    when 0
      known_attrs["title"] = "Unsorted"
    when -1
      known_attrs["title"] = "Unread"
    when -99
      known_attrs["title"] = "Trash"
    end
  end

  def self.load_all_collections(delay: 2)
    collections = RaindropIo::Collection.all
    # is there paging?  how do I get everything including their children?
    collections.each do |col|
      if Collection.where(_id: col._id).empty?
        column_names = Collection.column_names
        data = col.to_hash
        known_attrs = data.select { |k, v| column_names.include?(k) }
        unknown_attrs = data.except(*column_names)
        known_attrs["extra_data"] = unknown_attrs
        handle_blank_titles(known_attrs)
        Collection.create!(known_attrs)
        # sleep delay
      else
        puts "Duplicate collection, skipping _id: #{col._id} #{col.title}"
        # logger.debug "Duplicate collection, skipping _id: #{col._id} #{col.title}"
      end
    end
    Collection.all.map { |col| [col._id, col.title] }
  end

  # todo load collections and arrange them in a tree format

  def load_user
    user = RaindropIo::User.current_user
    if User.where(_id: user._id).empty?
      User.create!(_id: user._id, data: user.to_hash)
    end
  end

  def categorize_drops
    prompt = TTY::Prompt.new
    uncategorized_drops = Raindrop.where("collection ->> 'oid' = ?", "-1")
    n = 0
    uncategorized_drops.each do |drop|
      n += 1
      puts "\n\n\n\n(#{n}/#{uncategorized_drops.size}, #{uncategorized_drops.size - n} left) id: #{drop.id} #{pastel.yellow.bold(drop.title)} - #{drop.link}"
      drop.process!(client: openai_client)
      print "(u)se different url, (m)ove to another collection: "
      # design notes:
      #  * need to adjust tags
      #  * change category
      #  * change summary, maybe the url is not giving useful info
      #  * there might be tags or keywords that push to a category that we need to remember
      #  * a way to create new tags and categories, and push past and future categorizations to them
      #  TODO: maybe add descriptions to categories to help guide further refinements to the llm categorization
      # categorization based on past categorizations?
      ans = $stdin.gets.chomp
      case ans
      when "m"
        all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }.sort
        new_category = prompt.select("Select a category", all_categories, per_page: 20)
        target_collection = Collection.find_by(title: new_category)
        drop.move_to_collection(target_collection)
        drop.save!
      when "u"
        new_url = prompt.ask("Enter new url: ")
        drop.summarize_to_note(client: openai_client, alternative_url: new_url)
        drop.tag(client: openai_client)
        puts "new drop.note: #{pastel.red.bold(drop.note)}\n"
        if prompt.yes?("use new summary?")
          all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }
          new_category = prompt.select("Select a category", all_categories, per_page: 20)
          target_collection = Collection.find_by(title: new_category)
          drop.move_to_collection(target_collection)
          puts "saving..."
          drop.save!
        else
          puts "exiting.."
          exit 1
        end
      end

      drop.save!
      drop.push_data!
    end
  end

  def uncategorized_drops
    rel = Raindrop.where("collection ->> 'oid' = ?", "-1")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def drops_without_notes
    rel = Raindrop.where("note IS NULL or note = ''")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def drops_without_tags
    rel = Raindrop.where("tags IS NULL or tags = '[]'")
    if block_given?
      rel.each do |drop|
        yield drop
      end
    else
      rel
    end
  end

  def main
    loop do
      prompt = TTY::Prompt.new
      puts pastel.yellow.bold("\n\nNote that load is an action that loads from the remote API, and list is an action that lists the local database.\n\n")
      action = prompt.select("Choose an action", enum: ".", per_page: 30, cycle: true) do |menu|
        menu.choice "process unknown drops"
        menu.choice "repl"
        menu.choice "load raindrops"
        menu.choice "list raindrops"
        menu.choice "load collections"
        menu.choice "list collections"
        menu.choice "categorize drops"
        menu.choice "show user"
        menu.choice "exit"
      end

      case action
      when "repl"
        %w[uncategorized_drops drops_without_notes drops_without_tags].each do |method|
          puts pastel.green.bold("#{method}.each { |drop| } ")
        end
        binding.pry # rubocop:disable Lint/Debugger
      when "process unknown drops"
        ans = prompt.select("Select an action", %w[first specific all], cycle: true)
        last_id = nil
        loop do
          if ans == "specific"
            id = prompt.ask("Enter drop id (last id: #{last_id}): ") do |q|
              q.validate(/\d+/, "Invalid id")
            end
            drop = Raindrop.find(id)
            puts "Raindrop: #{drop.title} - #{drop.link}"
            puts "Current collection: #{drop.collection_link.title}"
            puts "Current tags: #{pastel.green.bold(drop.tags.join(", "))}"
            puts "Current note: #{drop.note}"

            cat = drop.pick_category(client: openai_client, collections: Collection.all, ask_user_input: true)
            if cat
              drop.move_to_collection(cat)
            end
            if prompt.yes?("Update note?")
              new_note = prompt.ask("Enter new note: ")
              drop.note = new_note
            end
            if prompt.yes?("update note summary?")
              drop.summarize_to_note(client: openai_client, debug: true)
            end
            drop.push_data!
            drop.save!
          elsif ans == "first"
            number_to_process = 1
            drops = drops_without_notes.first(number_to_process)
            rv = drops.first(number_to_process).map { |drop| drop.process!(client: openai_client) }
            last_id = drops.last.id
            puts "Processed #{rv} drops"
          elsif ans == "all"
            drops = drops_without_notes
            rv = drops.each_slice(10) do |slice|
              slice.map do |drop|
                if drop.extra_data["skip"] == true
                  puts "Skipping #{drop.id} #{drop.link}"
                else
                  puts
                  drop.process!(client: openai_client)
                end
              rescue SkipRaindrop => e
                puts "Error: #{e}, skipping #{drop.id} #{drop.link}"
                drop.reload
                drop.extra_data["skip"] = true
                drop.save
              rescue DeleteRaindrop => e
                puts "Error: #{e}, deleting #{drop.id} #{drop.link}"
                drop.remove!
                drop.destroy
              rescue SocketError => e
                puts "Error: #{e}, skipping #{drop.id} #{drop.link}"
                drop.extra_data["skip"] = true
                drop.save!
              end
            end
            last_id = drops.last.id
            puts "Processed #{rv.size} drops"
          else
            puts "Error: unknown action: #{ans}"
          end
          ans = prompt.select("\n\nSelect an action", %w[first specific exit], cycle: true)
          if ans == "exit"
            break
          end
        end
      when "load raindrops"
        drops = self.class.load_all_raindrops_in_col(0)
        binding.pry # rubocop:disable Lint/Debugger
      when "list raindrops"
        raindrops = Raindrop.all
        pager = TTY::Pager.new
        pager.page(raindrops.as_json.ai)
        binding.pry # rubocop:disable Lint/Debugger
      when "load collections"
        collections = self.class.load_all_collections
        ap collections
        binding.pry # rubocop:disable Lint/Debugger
      when "list collections"
        Collection.test
        binding.pry # rubocop:disable Lint/Debugger
      when "categorize drops"
        categorize_drops
      when "show user"
        cur_user = RaindropIo::User.current_user
        ap cur_user
        binding.pry # rubocop:disable Lint/Debugger
      when "exit"
        exit 0
      else
        puts "Unknown action: #{action}"
      end # case
    end # loop
  end # main
end # Processor

processor = Processor.new(command)
processor.main
