#!/usr/bin/env ruby

require_relative "../lib/raindrop_io"
require "dotenv/load"
require "optparse"
require "json"
require "logger"
require "awesome_print"
require "sqlite3"
require "pg"
require "active_record"
require "openai"
require "tty-prompt"
require "pastel"
require "readability"
require "net/http"
require "uri"
require "cgi"
require "yt"

Yt.configure do |config|
  config.log_level = :debug
  config.api_key = ENV["YOUTUBE_API_KEY"]
end

class Command
  attr_accessor :command, :object, :options, :token

  def initialize(args)
    @object = args[0]
    @command = args[1]
    args.shift(2)
    @options = args
    # look for token and set it
    if @options.include?("--token")
      @token = @options[@options.index("--token") + 1]
      @options.delete("--token")
      @options.delete(@token)
    end
    if ENV["RAINDROP_TOKEN"].size > 0
      @token = ENV["RAINDROP_TOKEN"]
    end
  end

  def require_opt!(opt)
    unless @options.include?(opt)
      warn "ERROR: Option #{opt} is required\n\n"
      usage
    end
  end

  def get_option(opt)
    if @options.include?(opt)
      idx = @options.index(opt)
      @options[idx + 1]
    end
  end

  def grammar
    {
      "collection" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => []},
      "raindrop" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => ["collection_id"]},
      "user" => {"get" => [], "post" => [], "put" => [], "delete" => [], "current_user" => []}
    }
  end

  def usage
    usage_str = grammar.map { |obj, verbs|
      "\t#{obj}: #{verbs.map { |cmd, req| "#{cmd}#{(req.size > 0) ? " (required: #{req.join(", ")})" : ""}" }.join(", ")}\n"
    }.join("\n")
    warn "Usage: #{$0} COMMAND OBJ [options]\n\n#{usage_str}\n"
    warn " options:\n    --token <token> : set the access token or set the RAINDROP_TOKEN environment variable"
    exit 1
  end
end

command = Command.new(ARGV)
command.usage if command.command.nil? || command.object.nil?

class Collection < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    collection_attrs = {
      int_fields: %w[_id count sort],
      string_fields: %w[color created lastUpdate title view description],
      bool_fields: %w[expanded public],
      object_fields: %w[access collaborators cover parent user creatorRef],
      extra_fields: %w[broken cache file important highlights lastAction slug author extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:collections)
        create_table :collections do |t|
          attrs = collection_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end
    end
  end
end

# | \_id             | `Integer`       | The id of the collection.
# | access           | `Object`
# | access.level     | `Integer`       | 1.  read only access (equal to `public=true`)  2.  collaborator with read only access  3.  collaborator with write only access  4.  owner
# | access.draggable | `Boolean`       | Does it possible to change parent of this collection?
# | collaborators    | `Object`        | When this object is present, means that collections is shared. Content of this object is private and not very useful. All sharing API methods [described here](https://developer.raindrop.io/v1/collections/sharing) |
# | color            | `String`        | Primary color of collection cover as `HEX`
# | count            | `Integer`       | Count of raindrops in collection
# | cover            | `Array<String>` | Collection cover URL. This array always have one item due to legacy reasons
# | created          | `String`        | When collection is created
# | expanded         | `Boolean`       | Whether the collectionâ€™s sub-collections are expanded
# | lastUpdate       | `String`        | When collection is updated
# | parent           | `Object`
# | parent.$id       | `Integer`       | The id of the parent collection. Not specified for root collections
# | public           | `Boolean`       | Collection and raindrops that it contains will be accessible without authentication by public link
# | sort             | `Integer`       | The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
# | title            | `String`        | Name of the collection
# | user             | `Object`
# | user.$id         | `Integer`       | Owner ID
# | view             | `String`        | View style of collection, can be:*   `list` (default) `simple` `grid` `masonry` Pinterest like grid
class Raindrop < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    raindrop_attrs = {
      int_fields: %w[_id count sort collectionId],
      string_fields: %w[color created domain excerpt note cover lastUpdate title type view link],
      bool_fields: %w[broken expanded public important removed],
      object_fields: %w[collection media tags collaborators parent user creatorRef cache file highlights reminder],
      extra_fields: %w[extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:raindrops)
        create_table :raindrops do |t|
          attrs = raindrop_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end # unless
    end
  end

  def scrape_url(url)
    source_url = URI.parse(url)
    response = Net::HTTP.get_response(source_url)
    Readability::Document.new(response.body).content
  end

  def model
    # "gpt-4"
    # "gtp-4-turbo"
    "gpt-3.5-turbo"
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a summary
  def summarize_to_note(client:)
    sys_prompt = "Given the title, the link and other information from a source, concisely summarize the following.  Depending on if this is a video, url, or playlist, website, etc. refer to it appropriately.  Only summarize the content given.  If there is not enough information to make a decision, return 'unknown'."

    if link.include?("youtube.com")
      puts Pastel.new.red.bold("Youtube link detected, extracting description.")

      # if it's a youtube live link, extract the id
      uri = URI.parse(link)
      if uri.path.include?("/live")
        yt_id = uri.path.split("/").last
        parsed_url = {"v" => [yt_id]}
      else
        parsed_url = CGI.parse(URI.parse(link).query)
      end
      if parsed_url["v"].first
        yt_id = parsed_url["v"].first
        video = Yt::Video.new id: yt_id
        # have the LLM summarize the description
        prompt = "Summarize the following youtube description, refer to it as 'This video'.  Also reference the channel name, '#{video.channel_title}'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{video.title}\ncategory: #{video.category_title}\ntags: #{video.tags.join(", ")}\ndescription: #{video.description}"
      elsif parsed_url["list"].first
        yt_id = parsed_url["list"].first
        playlist = Yt::Playlist.new id: yt_id
        prompt = "Summarize the following youtube playlist, refer to it as 'This youtube playlist'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{playlist.title}\ndescription: #{playlist.description}"
      else
        puts "No video id found in url, skipping."
        binding.pry # rubocop:disable Lint/Debugger
      end
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      self.note = response.dig("choices", 0, "message", "content")
    else
      content = scrape_url(link)
      puts Pastel.new.green.bold("Scraped content: #{content[0..500].inspect}")
    end

    prompt = if content
      "Summarize the following content, refer to it as best you can, it might be a blog, weekly newsletter, a news site, an article, a github repo, etc.  Try to be concise and specific as you can, for an expert. if it is a github repo, do not mention getting an account to contribute.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\n#{content}"
    else
      "title: #{title}\nurl: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\n"
    end
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    self.note = response.dig("choices", 0, "message", "content")
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a set of tags
  def tag(client:)
    sys_prompt = "Given the title, the link and other information from a bookmark, generate a set of tags for the following text.  however, strive to keep the number of tags to a minimum, if there are multiple tags within the same area, chose a tag that cover the most, to keep the number of tags down.If there is not enough information to make a decision, return 'unknown'."
    prompt = "#{title}\n#{link}\n#{excerpt}\n#{note}\n#{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    incoming_tag = response.dig("choices", 0, "message", "content").split.map { |i| i.delete("#").strip }
    self.tags = incoming_tag.reject { |i| i =~ /^\p{Punct}$/ || i == "" }.compact
  end

  def pick_category(client:, collections:)
    cleaned_collections = collections.map(&:title).compact.reject { |i| i == "" || i == "Unread" }
    sys_prompt = "Given the title, the link and other information from a bookmark, categorize the following text into one of the following categories: #{cleaned_collections.join(", ")}\nRespond with ONLY the category from the list above, with no extra formatting or words.  If none apply, use 'unknown'."
    prompt = "title: #{title}\nlink: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\ndomain: #{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    collection_title = response.dig("choices", 0, "message", "content")
    if collection_title == "unknown"
      # ask if a new collection should be created
      sys_prompt = "This does not currently fit any of the existing categories (#{cleaned_collections.join(", ")}).  Suggest a new category this bookmark can be filed under.  Respond with only the proposed category, it should be short, without any spaces or punctuation, with only dashes to separate words if necessary."
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      proposed_collection_title = response.dig("choices", 0, "message", "content")
      puts "Proposed collection title: #{proposed_collection_title}, use it to create a new collection? (yes/no)"
      answer = $stdin.gets.chomp
      if answer == "yes"
        col = RaindropIo::Collection.create!(title: proposed_collection_title)
        Collection.create!(title: proposed_collection_title)
        return col
      else
        puts "No new collection created, dropping into debugger"
        binding.pry # rubocop:disable Lint/Debugger
      end
    end
    col = Collection.find_by(title: collection_title)
    if col.nil?
      binding.pry # rubocop:disable Lint/Debugger
    end
    col
  end

  def move_to_collection(target_collection)
    self.collectionId = target_collection._id
    self.collection = {"$ref" => "collections", "$id" => collectionId, "oid" => collectionId}
    puts "Moving to collection #{Pastel.new.red.bold(target_collection.title)} (#{collection.inspect})!"
  end

  def suggest
    RaindropIo::Raindrop.suggest(_id)
  end

  def pull_data
  end

  def push_data!
    # update the raindrop with the new data
    resp = RaindropIo::Raindrop.update(_id, data: attributes.except(:id, "id"))
    if resp.is_a?(RaindropIo::Raindrop)
      puts Pastel.new.green("Successfully updated raindrop, #{resp.attributes["title"]}")
      # assign attributes from the resposne raindrop to the current and save
      resp.attributes.each do |k, v|
        if has_attribute?(k)
          self[k] = v
        else
          self[:extra_data][k] = v
        end
      rescue
        puts "Failed to assign #{k} to #{v}"
        raise
      end
      save!
    else
      puts "Failed to update raindrop. #{resp.inspect}"
    end
  end
end

class User < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    ActiveRecord::Schema.define do
      unless table_exists?(:users)
        create_table :users do |t|
          t.integer :_id
          t.jsonb :data, null: false, default: {}
        end
      end # unless
    end # Schema.define
  end
end

class DBHandler
  attr_accessor :db_type

  def initialize(db_type)
    @db_type = db_type.to_s
    raise "Invalid db_type" unless @db_type == "postgres" || @db_type == "sqlite3"
  end

  def db_config
    (db_type == "postgres") ? postgres_config : sqlite3_config
  end

  def sqlite3_config
    {adapter: "sqlite3", database: "raindrop_io.db"}
  end

  def postgres_config
    # username: "", # password: "your_password",
    {adapter: "postgresql", database: "raindrop", encoding: "unicode", host: "localhost"}
  end

  def connect
    # File.exist?("raindrop_io.db")
    ActiveRecord::Base.establish_connection(db_config)
    # the database needs to exist already, can't figure out how to create it from here
    ActiveRecord::Base.connection
  rescue => e
    puts "WARNING: error connecting to db. #{e}"
    # ActiveRecord::Base.establish_connection(config.merge("database" => "postgres"))
    # ActiveRecord::Base.connection.create_database(config["database"], config)
    # ActiveRecord::Base.establish_connection(config)
  end

  def migrate!
    Collection.do_migration
    Raindrop.do_migration
    User.do_migration
  end

  def drop!
    tables = %w[collections raindrops users]
    tables.each do |table|
      ActiveRecord::Base.connection.drop_table table if ActiveRecord::Base.connection.table_exists? table
    end
  end

  def dump_to_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end

  def load_from_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end
end

puts "DEBUG: command: #{command.inspect}"
class Processor
  attr_accessor :command, :logger, :db, :openai_client, :pastel

  def initialize(command)
    @db = DBHandler.new(:postgres)
    @db.connect
    # ActiveRecord::Base.establish_connection(@db.db_config)
    @command = command
    @logger = Logger.new("raindrop_io.log")
    @logger.level = Logger::DEBUG
    # set the access token and logger
    RaindropIo::Api.configure do |config|
      config.api_token = command.token
      config.logger = @logger
    end
    @openai_client = OpenAI::Client.new(access_token: ENV["OPENAI_API_KEY"])
    @pastel = ::Pastel.new
  end

  def load_all_raindrops(col_id, delay: 2)
    drops = RaindropIo::Raindrop.raindrops(col_id)
    total_pages = drops[:total] / RaindropIo::Raindrop.default_page_size
    (0...total_pages).each do |page|
      drops = RaindropIo::Raindrop.raindrops(col_id, page: page)
      sleep_counter = 0

      drops[:items].each do |drop|
        if Raindrop.where(_id: drop._id).empty? # avoid dupes
          column_names = ::Raindrop.column_names
          data = drop.to_hash
          # Separate the data into known and extra attributes, since things change
          known_attrs = data.select { |k, v| column_names.include?(k) }
          unknown_attrs = data.except(*column_names)
          known_attrs["extra_data"] = unknown_attrs
          drop = Raindrop.create!(known_attrs)
          ap drop.as_json
          sleep_counter += 1
          if sleep_counter % 10 == 0
            puts "Sleeping for #{delay} seconds"
            sleep delay
          end
        else
          puts "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
          logger.debug "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
        end
      end
      ap "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
      logger.debug "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
    end
  end

  def load_all_collections(delay: 2)
    collections = RaindropIo::Collection.all
    # is there paging?  how do I get everything including their children?
    collections.each do |col|
      if Collection.where(_id: col._id).empty?
        column_names = Collection.column_names
        data = col.to_hash
        known_attrs = data.select { |k, v| column_names.include?(k) }
        unknown_attrs = data.except(*column_names)
        known_attrs["extra_data"] = unknown_attrs
        Collection.create!(known_attrs)
        # sleep delay
      else
        puts "Duplicate collection, skipping _id: #{col._id} #{col.title}"
        logger.debug "Duplicate collection, skipping _id: #{col._id} #{col.title}"
      end
    end
    Collection.all.map { |col| ap [col._id, col.title] }
  end

  def load_user
    user = RaindropIo::User.current_user
    if User.where(_id: user._id).empty?
      User.create!(_id: user._id, data: user.to_hash)
    end
  end

  def main
    case command.object
    when "command", "cmd"
      case command.command
      when "categorize"
        # find all raindrops that are not categorized
        Raindrop.where("collection ->> 'oid' = ?", "-1").each do |drop|
          category = drop.pick_category(client: @openai_client, collections: Collection.all)
          drop.move_to_collection(category)
          drop.save!
        end
        binding.pry # rubocop:disable Lint/Debugger
      when "line"
        # db.migrate!
        # db.drop!
        # load_all_raindrops(0)
        # load_user
        # ap models = @openai_client.models.list
        # drop = Raindrop.find_by(_id: 775506251)
        Raindrop.where("collection ->> 'oid' = ?", "-1").each do |drop|
          drop.summarize_to_note(client: openai_client)
          drop.tag(client: openai_client)
          target_collection = drop.pick_category(client: @openai_client, collections: Collection.all)
          if target_collection.nil?
            puts pastel.red("No target collection found for #{drop.title}\nDrop id: #{drop.id}/#{drop._id}  #{pastel.bold(drop.title)}")
            binding.pry # rubocop:disable Lint/Debugger
            next
          end
          drop.move_to_collection(target_collection)
          puts "\n"
          drop.save!
          drop.push_data!
          puts "title: #{pastel.yellow(drop.title)}\n#{pastel.red.bold(drop.note)}\n#{drop.tags.map { |t| pastel.cyan(t) }.join(", ")}\n"
          print "\nContine [enter], reload collections [c], move to another collection [m], debug [d], quit [q] : "
          ans = $stdin.gets.chomp
          case ans
          when "d"
            binding.pry # rubocop:disable Lint/Debugger
          when "q"
            exit 0
          when "c"
            load_all_collections
          when "m"
            prompt = TTY::Prompt.new
            all_categories = Collection.all.map { |c| c.title }
            new_category = prompt.enum_select("Select a category", all_categories)
            target_collection = Collection.find_by(title: new_category)
            drop.move_to_collection(target_collection)
            drop.save!
          when ""
            puts "Continuing...\n"
          else
            puts "unknown command #{ans.inspect}\n\n"
            binding.pry # rubocop:disable Lint/Debugger
          end
        end

        # drop.summarize_to_note(client: openai_client)
        # drop.tag(client: openai_client)
        # target_collection = drop.pick_category(client: @openai_client, collections: Collection.all)
        # drop.move_to_collection(target_collection)
        # drop.save!
        # drop.push_data!
        # binding.pry # rubocop:disable Lint/Debugger
      end
    when "collection"
      case command.command
      when "list"
        collections = Collection.all
        ap collections.as_json
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "raindrop"
      case command.command
      when "get"
        ap RaindropIo::Raindrop.get(command.options[:id])
      when "post"
        ap RaindropIo::Raindrop.post(command.options[:id])
      when "put"
        ap RaindropIo::Raindrop.put(command.options[:id])
      when "delete"
        ap RaindropIo::Raindrop.delete(command.options[:id])
      when "list"
        raindrops = Raindrop.all
        ap raindrops.as_json
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "user"
      case command.command
      when "delete"
        ap RaindropIo::User.delete(command.options[:id])
      when "current_user"
        ap RaindropIo::User.current_user
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    else
      puts "ERROR: command '#{command.object}' not found\n\n"
    end
  end
end

processor = Processor.new(command)
processor.main
