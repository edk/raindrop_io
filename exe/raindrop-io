#!/usr/bin/env ruby

require_relative "../lib/raindrop_io"
require "optparse"
require "json"
require "logger"
require "awesome_print"
require "sqlite3"
require "pg"
require "active_record"

class Command
  attr_accessor :command, :object, :options, :token

  def initialize(args)
    @object = args[0]
    @command = args[1]
    args.shift(2)
    @options = args
    # look for token and set it
    if @options.include?("--token")
      @token = @options[@options.index("--token") + 1]
      @options.delete("--token")
      @options.delete(@token)
    end
    if ENV["RAINDROP_TOKEN"].size > 0
      @token = ENV["RAINDROP_TOKEN"]
    end
  end

  def require_opt!(opt)
    unless @options.include?(opt)
      warn "ERROR: Option #{opt} is required\n\n"
      usage
    end
  end

  def get_option(opt)
    if @options.include?(opt)
      idx = @options.index(opt)
      @options[idx + 1]
    end
  end

  def grammar
    {
      "collection" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => []},
      "raindrop" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => ["collection_id"]},
      "user" => {"get" => [], "post" => [], "put" => [], "delete" => [], "current_user" => []}
    }
  end

  def usage
    usage_str = grammar.map { |obj, verbs|
      "\t#{obj}: #{verbs.map { |cmd, req| "#{cmd}#{(req.size > 0) ? " (required: #{req.join(", ")})" : ""}" }.join(", ")}\n"
    }.join("\n")
    warn "Usage: #{$0} COMMAND OBJ [options]\n\n#{usage_str}\n"
    warn " options:\n    --token <token> : set the access token or set the RAINDROP_TOKEN environment variable"
    exit 1
  end
end

command = Command.new(ARGV)
command.usage if command.command.nil? || command.object.nil?

class Collection < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    collection_attrs = {
      int_fields: %w[_id count sort],
      string_fields: %w[color created lastUpdate title view description],
      bool_fields: %w[expanded public],
      object_fields: %w[access collaborators cover parent user creatorRef],
      extra_fields: %w[broken cache file important highlights lastAction slug author extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:collections)
        create_table :collections do |t|
          attrs = collection_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end
    end
  end
end

# | \_id             | `Integer`       | The id of the collection.
# | access           | `Object`
# | access.level     | `Integer`       | 1.  read only access (equal to `public=true`)  2.  collaborator with read only access  3.  collaborator with write only access  4.  owner
# | access.draggable | `Boolean`       | Does it possible to change parent of this collection?
# | collaborators    | `Object`        | When this object is present, means that collections is shared. Content of this object is private and not very useful. All sharing API methods [described here](https://developer.raindrop.io/v1/collections/sharing) |
# | color            | `String`        | Primary color of collection cover as `HEX`
# | count            | `Integer`       | Count of raindrops in collection
# | cover            | `Array<String>` | Collection cover URL. This array always have one item due to legacy reasons
# | created          | `String`        | When collection is created
# | expanded         | `Boolean`       | Whether the collectionâ€™s sub-collections are expanded
# | lastUpdate       | `String`        | When collection is updated
# | parent           | `Object`
# | parent.$id       | `Integer`       | The id of the parent collection. Not specified for root collections
# | public           | `Boolean`       | Collection and raindrops that it contains will be accessible without authentication by public link
# | sort             | `Integer`       | The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
# | title            | `String`        | Name of the collection
# | user             | `Object`
# | user.$id         | `Integer`       | Owner ID
# | view             | `String`        | View style of collection, can be:*   `list` (default) `simple` `grid` `masonry` Pinterest like grid
class Raindrop < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    raindrop_attrs = {
      int_fields: %w[_id count sort collectionId],
      string_fields: %w[color created domain excerpt note cover lastUpdate title type view link],
      bool_fields: %w[broken expanded public important removed],
      object_fields: %w[collection media tags collaborators parent user creatorRef cache file highlights reminder],
      extra_fields: %w[extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:raindrops)
        create_table :raindrops do |t|
          attrs = raindrop_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end # unless
    end
  end
end

class User < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    ActiveRecord::Schema.define do
      unless table_exists?(:users)
        create_table :users do |t|
          t.jsonb :data, null: false, default: {}
        end
      end # unless
    end # Schema.define
  end
end

class DBHandler
  attr_accessor :db_type
  def initialize(db_type)
    @db_type = db_type.to_s
    raise "Invalid db_type" unless @db_type == "postgres" || @db_type == "sqlite3"
  end

  def db_config
    (db_type == "postgres") ? postgres_config : sqlite3_config
  end

  def sqlite3_config
    {adapter: "sqlite3", database: "raindrop_io.db"}
  end

  def postgres_config
    # username: "", # password: "your_password",
    {adapter: "postgresql", database: "raindrop", encoding: "unicode", host: "localhost"}
  end

  def connect
    # File.exist?("raindrop_io.db")
    ActiveRecord::Base.establish_connection(db_config)
    # the database needs to exist already, can't figure out how to create it from here
    ActiveRecord::Base.connection
  rescue => e
    puts "WARNING: error connecting to db. #{e}"
    # ActiveRecord::Base.establish_connection(config.merge("database" => "postgres"))
    # ActiveRecord::Base.connection.create_database(config["database"], config)
    # ActiveRecord::Base.establish_connection(config)
  end

  def migrate!
    Collection.do_migration
    Raindrop.do_migration
    User.do_migration
  end
  
  def drop!
    tables = %w[collections raindrops users]
    tables.each do |table|
      ActiveRecord::Base.connection.drop_table table if ActiveRecord::Base.connection.table_exists? table
    end
  end
end

puts "DEBUG: command: #{command.inspect}"
class Processor
  attr_accessor :command, :logger, :db

  def initialize(command)
    @db = DBHandler.new(:postgres)
    @db.connect
    # ActiveRecord::Base.establish_connection(@db.db_config)
    @command = command
    @logger = Logger.new("raindrop_io.log")
    @logger.level = Logger::DEBUG
    # set the access token and logger
    RaindropIo::Api.configure do |config|
      config.api_token = command.token
      config.logger = @logger
    end
  end

  def load_all_raindrops(col_id, delay: 2)
    drops = RaindropIo::Raindrop.raindrops(col_id)
    total_pages = drops[:total] / RaindropIo::Raindrop.default_page_size
    (0...total_pages).each do |page|
      drops = RaindropIo::Raindrop.raindrops(col_id, page: page)
      sleep_counter = 0

      drops[:items].each do |drop|
        puts drop.attributes.to_json
        # only add if url is not already in the db
        if ::Raindrop.where(link: drop.link).empty?
          column_names = ::Raindrop.column_names
          data = drop.to_hash
          data.each do |k, v|
            if v.is_a?(Hash) || v.is_a?(Array)
              data[k] = v.to_json
            end
          end
          # Separate the data into known and extra attributes
          known_attrs = data.select { |k, v| column_names.include?(k) }
          unknown_attrs = data.except(*column_names)

          known_attrs["extra_data"] = unknown_attrs.to_json
          d1 = ::Raindrop.create!(known_attrs)
          ap d1
          sleep_counter += 1
          if sleep_counter % 10 == 0
            puts "Sleeping for #{delay} seconds"
            sleep delay
          end
        else
          puts "Duplicate link, skipping id: #{drop} #{drop.link}"
          logger.debug "Duplicate link, skipping id: #{drop} #{drop.link}"
        end
      end
      ap "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
      logger.debug "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
    end
  end

  def main
    case command.object
    when "command", "cmd"
      case command.command
      when "line"
        # db.migrate!
        # db.drop!
        # load_all_raindrops(0)
        binding.pry
      end
    when "collection"
      case command.command
      when "get"
        ap RaindropIo::Collection.get(command.options[:id])
      when "post"
        ap RaindropIo::Collection.post(command.options[:id])
      when "put"
        ap RaindropIo::Collection.put(command.options[:id])
      when "delete"
        ap RaindropIo::Collection.delete(command.options[:id])
      when "list"
        collections = RaindropIo::Collection.all
        ap collections
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "raindrop"
      case command.command
      when "get"
        ap RaindropIo::Raindrop.get(command.options[:id])
      when "post"
        ap RaindropIo::Raindrop.post(command.options[:id])
      when "put"
        ap RaindropIo::Raindrop.put(command.options[:id])
      when "delete"
        ap RaindropIo::Raindrop.delete(command.options[:id])
      when "list"
        command.require_opt!("--collection_id")
        drops = RaindropIo::Raindrop.raindrops(command.get_option("--collection_id"))
        ap drops
        json = JSON.generate(drops)
        # todo: add pagination, maybe interactive with tty-prompt?
        binding.pry
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "user"
      case command.command
      when "get"
        ap RaindropIo::User.get(command.options[:id])
      when "post"
        ap RaindropIo::User.post(command.options[:id])
      when "put"
        ap RaindropIo::User.put(command.options[:id])
      when "delete"
        ap RaindropIo::User.delete(command.options[:id])
      when "current_user"
        ap RaindropIo::User.current_user
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    end
  end
end

processor = Processor.new(command)
processor.main
