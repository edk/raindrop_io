#!/usr/bin/env ruby

require_relative "../lib/raindrop_io"
require "dotenv/load"
require "optparse"
require "json"
require "logger"
require "awesome_print"
require "sqlite3"
require "pg"
require "active_record"
require "openai"
require "tty-prompt"
require "pastel"
require "readability"
require "poppler"
require "net/http"
require "uri"
require "open-uri"
require "puppeteer-ruby"
require "cgi"
require "yt"

Yt.configure do |config|
  config.log_level = :debug
  config.api_key = ENV["YOUTUBE_API_KEY"]
end

class Command
  attr_accessor :command, :object, :options, :token

  def initialize(args)
    @object = args[0]
    @command = args[1]
    args.shift(2)
    @options = args
    # look for token and set it
    if @options.include?("--token")
      @token = @options[@options.index("--token") + 1]
      @options.delete("--token")
      @options.delete(@token)
    end
    if ENV["RAINDROP_TOKEN"].size > 0
      @token = ENV["RAINDROP_TOKEN"]
    end
  end

  def require_opt!(opt)
    unless @options.include?(opt)
      warn "ERROR: Option #{opt} is required\n\n"
      usage
    end
  end

  def get_option(opt)
    if @options.include?(opt)
      idx = @options.index(opt)
      @options[idx + 1]
    end
  end

  def grammar
    {
      "collection" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => []},
      "raindrop" => {"get" => [], "post" => [], "put" => [], "delete" => [], "list" => ["collection_id"]},
      "user" => {"get" => [], "post" => [], "put" => [], "delete" => [], "current_user" => []}
    }
  end

  def usage
    usage_str = grammar.map { |obj, verbs|
      "\t#{obj}: #{verbs.map { |cmd, req| "#{cmd}#{(req.size > 0) ? " (required: #{req.join(", ")})" : ""}" }.join(", ")}\n"
    }.join("\n")
    warn "Usage: #{$0} COMMAND OBJ [options]\n\n#{usage_str}\n"
    warn " options:\n    --token <token> : set the access token or set the RAINDROP_TOKEN environment variable"
    exit 1
  end
end

command = Command.new(ARGV)
command.usage if command.command.nil? || command.object.nil?

class Collection < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    collection_attrs = {
      int_fields: %w[_id count sort],
      string_fields: %w[color created lastUpdate title view description],
      bool_fields: %w[expanded public],
      object_fields: %w[access collaborators cover parent user creatorRef],
      extra_fields: %w[broken cache file important highlights lastAction slug author extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:collections)
        create_table :collections do |t|
          attrs = collection_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end
    end
  end
end

# | \_id             | `Integer`       | The id of the collection.
# | access           | `Object`
# | access.level     | `Integer`       | 1.  read only access (equal to `public=true`)  2.  collaborator with read only access  3.  collaborator with write only access  4.  owner
# | access.draggable | `Boolean`       | Does it possible to change parent of this collection?
# | collaborators    | `Object`        | When this object is present, means that collections is shared. Content of this object is private and not very useful. All sharing API methods [described here](https://developer.raindrop.io/v1/collections/sharing) |
# | color            | `String`        | Primary color of collection cover as `HEX`
# | count            | `Integer`       | Count of raindrops in collection
# | cover            | `Array<String>` | Collection cover URL. This array always have one item due to legacy reasons
# | created          | `String`        | When collection is created
# | expanded         | `Boolean`       | Whether the collectionâ€™s sub-collections are expanded
# | lastUpdate       | `String`        | When collection is updated
# | parent           | `Object`
# | parent.$id       | `Integer`       | The id of the parent collection. Not specified for root collections
# | public           | `Boolean`       | Collection and raindrops that it contains will be accessible without authentication by public link
# | sort             | `Integer`       | The order of collection (descending). Defines the position of the collection among all the collections with the same `parent.$id`
# | title            | `String`        | Name of the collection
# | user             | `Object`
# | user.$id         | `Integer`       | Owner ID
# | view             | `String`        | View style of collection, can be:*   `list` (default) `simple` `grid` `masonry` Pinterest like grid
class Raindrop < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    raindrop_attrs = {
      int_fields: %w[_id count sort collectionId],
      string_fields: %w[color created domain excerpt note cover lastUpdate title type view link],
      bool_fields: %w[broken expanded public important removed],
      object_fields: %w[collection media tags collaborators parent user creatorRef cache file highlights reminder],
      extra_fields: %w[extra_data]
    }
    ActiveRecord::Schema.define do
      unless table_exists?(:raindrops)
        create_table :raindrops do |t|
          attrs = raindrop_attrs
          attrs[:int_fields].each { |attr| t.integer attr }
          attrs[:string_fields].each { |attr| t.string attr }
          attrs[:bool_fields].each { |attr| t.boolean attr }
          attrs[:object_fields].each { |attr| t.jsonb attr }
          attrs[:extra_fields].each { |attr| t.jsonb attr }
        end
      end # unless
    end
  end

  def resolve_uri(base_uri, new_location)
    return URI(new_location) if new_location.start_with?("http")
    URI.join(base_uri, new_location)
  end

  def fetch_uri(uri, limit: 10)
    raise ArgumentError, "HTTP redirect too deep" if limit.zero?

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = uri.scheme == "https"
    request = Net::HTTP::Get.new(uri.request_uri)
    request["User-Agent"] = ["Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"]

    response = http.request(request)

    case response
    when Net::HTTPSuccess
      response
    when Net::HTTPRedirection
      fetch_uri(resolve_uri(uri, response["location"]), limit: limit - 1)
    else
      response
    end
  end

  def scrape_url(url, debug: false)
    source_url = URI.parse(url)
    response = fetch_uri(source_url)

    binding.pry if debug # rubocop:disable Lint/Debugger
    content_type = response["content-type"]
    if /forbidden/i.match?(response.message) ||
        /You need to enable JavaScript/i.match?(response.body)
      use_puppeteer = true
      force_html = true
      content_type = "text/html"
    else
      use_puppeteer = false
      force_html = false
    end
    puts "DEBUG: content_type: #{content_type} force_html: #{force_html} use_puppeteer: #{use_puppeteer}"

    case content_type
    when %r{text/html}
      if !use_puppeteer
        Readability::Document.new(response.body).content
      else
        content = nil
        Puppeteer.launch(headless: true, args: ["--enable-javascript"]) do |browser|
          page = browser.pages.first || browser.new_page
          user_agent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
          page.user_agent = user_agent
          response = page.goto(url)
          if response.status != 200
            puts "Failed to load page: #{response.status}"
            binding.pry
            return nil
          end
          page.wait_for_timeout(3000) # Wait for JavaScript to execute
          # page.wait_for_navigation(wait_until: "networkidle0")
          content = page.evaluate("() => document.body.innerHTML")
        end
        puts "content: #{content[0..500].inspect}"
        content = Readability::Document.new(content).content
      end
    when "application/pdf"
      file = URI.open(url)
      pdf = Poppler::Document.new(file.path)
      pdf.map do |page|
        page.get_text
      end.join("\n")
    end
  end

  def model
    # "gpt-4"
    # "gtp-4-turbo"
    "gpt-3.5-turbo"
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a summary
  def summarize_to_note(client:, alternative_url: nil, debug: false)
    sys_prompt = "Given the title, the link and other information from a source, concisely summarize and describe the contents of the URI using the following information.  Depending on if this is a video, url, or playlist, website, etc. refer to it appropriately.  Only summarize and describe the content given for an expert.  If there is not enough information to make a decision, return 'unknown'."

    if link.include?("youtube.com")
      puts Pastel.new.red.bold("Youtube link detected, extracting description.")

      # if it's a youtube live link, extract the id
      uri = URI.parse(alternative_url || link)
      if uri.path.include?("/live")
        yt_id = uri.path.split("/").last
        parsed_url = {"v" => [yt_id]}
      else
        parsed_url = CGI.parse(URI.parse(link).query)
      end
      if parsed_url["v"].first
        yt_id = parsed_url["v"].first
        video = Yt::Video.new id: yt_id
        # have the LLM summarize the description
        prompt = "Summarize the following youtube description, refer to it as 'This video'.  Also reference the channel name, '#{video.channel_title}'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{video.title}\ncategory: #{video.category_title}\ntags: #{video.tags.join(", ")}\ndescription: #{video.description}"
      elsif parsed_url["list"].first
        yt_id = parsed_url["list"].first
        playlist = Yt::Playlist.new id: yt_id
        prompt = "Summarize the following youtube playlist, refer to it as 'This youtube playlist'.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\ntitle: #{playlist.title}\ndescription: #{playlist.description}"
      else
        puts "No video id found in url, skipping."
        binding.pry # rubocop:disable Lint/Debugger
      end
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      self.note = response.dig("choices", 0, "message", "content")
    else
      uri = URI.parse(alternative_url || link)
      content = scrape_url(uri.to_s, debug: debug)
      # truncate content to keep it under 3000 characters
      binding.pry if content.nil?
      content = content[0..3000] if content.size > 3000
      puts "DEBUG: content: #{content[0..500].inspect}" if debug
      puts Pastel.new.yellow("Scraped content: #{content[0..500].inspect}")
    end

    prompt = if content
      "Summarize the following content, refer to it as best you can, it might be a blog, weekly newsletter, a news site, an article, a github repo, etc.  Try to be concise and specific as you can, for an expert. if it is a github repo, do not mention getting an account to contribute.  Keep it short and concise as it will be added to the notes column of a bookmarks table.\n#{content}"
    else
      "title: #{title}\nurl: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\n"
    end
    binding.pry if debug # rubocop:disable Lint/Debugger
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    self.note = response.dig("choices", 0, "message", "content")
  end

  # @todo:
  # retag existing bookmarks
  def retag(raindrops)
    # load the current tags
    # use a prompt to parse and generate new tags based on more stringent criteria
  end

  # given the existing raindrop, and field such as title, excerpt, type, etc
  # ask the LLM to generate a set of tags
  def tag(client:)
    sys_prompt = "Given the title, the link and other information from a bookmark, generate a set of tags for the following text.  however, strive to keep the number of tags to a minimum, if there are multiple tags within the same area, chose a tag that cover the most, to keep the number of tags down. Do not generate empty, overly broad or meaningless tags that do not help find the content of this bookmark. for multi-word tags, use dashes between words.  e.g. Ruby-on-Rails, vs Ruby on Rails, or Visual-Studio-Code vs Visual Studio Code, as the tagging system is word based.  If there is not enough information to make a decision, return 'unknown'."
    prompt = "#{title}\n#{link}\n#{excerpt}\n#{note}\n#{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    incoming_tag = response.dig("choices", 0, "message", "content").split.map { |i| i.delete("#").delete(",").strip }
    self.tags = incoming_tag.reject { |i| i =~ /^\p{Punct}$/ || i == "" }.compact
  end

  def pick_category(client:, collections:)
    cleaned_collections = collections.map(&:title).compact.reject { |i| i == "" || i == "Unread" }
    sys_prompt = "Given the title, the link and other information from a bookmark, categorize the following text into one of the following categories: #{cleaned_collections.join(", ")}\nRespond with ONLY the category from the list above, with no extra formatting or words.  If none apply, use 'unknown'."
    prompt = "title: #{title}\nlink: #{link}\nexcerpt: #{excerpt}\nnote: #{note}\ndomain: #{domain}"
    response = client.chat(
      parameters: {
        model: model,
        messages: [
          {role: "system", content: sys_prompt},
          {role: "user", content: prompt}
        ],
        temperature: 0.2
      }
    )
    collection_title = response.dig("choices", 0, "message", "content")
    if /unknown/i.match?(collection_title)
      # ask if a new collection should be created
      sys_prompt = "This does not currently fit any of the existing categories (#{cleaned_collections.join(", ")}).  Suggest a new category this bookmark can be filed under.  Respond with only the proposed category, it should be short, without any spaces or punctuation, with only dashes to separate words if necessary."
      response = client.chat(
        parameters: {
          model: model,
          messages: [
            {role: "system", content: sys_prompt},
            {role: "user", content: prompt}
          ],
          temperature: 0.2
        }
      )
      proposed_collection_title = response.dig("choices", 0, "message", "content")
      puts "Proposed collection title: #{proposed_collection_title}, use it to create a new collection? (yes/no)"
      answer = $stdin.gets.chomp
      if answer == "yes"
        col = RaindropIo::Collection.create!(title: proposed_collection_title)
        Collection.create!(title: proposed_collection_title)
        return col
      else
        puts "No new collection created, dropping into debugger"
        binding.pry # rubocop:disable Lint/Debugger
      end
    end
    col = Collection.find_by(title: collection_title)
    if col.nil?
      # create new collection
      attrs = {
        title: collection_title,
        public: false
        # parent: {"$ref" => "collections", "$id" => parent_id, "oid" => parent_id}
      }
      debugger
      col = RaindropIo::Collection.create!(attrs)
      binding.pry # rubocop:disable Lint/Debugger
    end
    col
  end

  def move_to_collection(target_collection)
    self.collectionId = target_collection._id
    self.collection = {"$ref" => "collections", "$id" => collectionId, "oid" => collectionId}
    puts "Moving to collection: #{Pastel.new.green.bold(target_collection.title)} (#{collection.inspect})!"
  end

  def suggest
    RaindropIo::Raindrop.suggest(_id)
  end

  def pull_data
  end

  def push_data!
    # update the raindrop with the new data
    resp = RaindropIo::Raindrop.update(_id, data: attributes.except(:id, "id"))
    if resp.is_a?(RaindropIo::Raindrop)
      puts Pastel.new.green("Successfully updated raindrop, #{resp.attributes["title"]}")
      # assign attributes from the resposne raindrop to the current and save
      resp.attributes.each do |k, v|
        if has_attribute?(k)
          self[k] = v
        else
          self[:extra_data][k] = v
        end
      rescue
        puts "Failed to assign #{k} to #{v}"
        raise
      end
      save!
    else
      puts "Failed to update raindrop. #{resp.inspect}"
    end
  end
end

class User < ActiveRecord::Base
  self.inheritance_column = nil

  def self.do_migration
    ActiveRecord::Schema.define do
      unless table_exists?(:users)
        create_table :users do |t|
          t.integer :_id
          t.jsonb :data, null: false, default: {}
        end
      end # unless
    end # Schema.define
  end
end

class DBHandler
  attr_accessor :db_type

  def initialize(db_type)
    @db_type = db_type.to_s
    raise "Invalid db_type" unless @db_type == "postgres" || @db_type == "sqlite3"
  end

  def db_config
    (db_type == "postgres") ? postgres_config : sqlite3_config
  end

  def sqlite3_config
    {adapter: "sqlite3", database: "raindrop_io.db"}
  end

  def postgres_config
    # username: "", # password: "your_password",
    {adapter: "postgresql", database: "raindrop", encoding: "unicode", host: "localhost"}
  end

  def connect
    # File.exist?("raindrop_io.db")
    ActiveRecord::Base.establish_connection(db_config)
    # the database needs to exist already, can't figure out how to create it from here
    ActiveRecord::Base.connection
  rescue => e
    puts "WARNING: error connecting to db. #{e}"
    # ActiveRecord::Base.establish_connection(config.merge("database" => "postgres"))
    # ActiveRecord::Base.connection.create_database(config["database"], config)
    # ActiveRecord::Base.establish_connection(config)
  end

  def migrate!
    Collection.do_migration
    Raindrop.do_migration
    User.do_migration
  end

  def drop!
    tables = %w[collections raindrops users]
    tables.each do |table|
      ActiveRecord::Base.connection.drop_table table if ActiveRecord::Base.connection.table_exists? table
    end
  end

  def dump_to_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end

  def load_from_sql(file_path)
    case @db_type
    when "postgres"
      config = postgres_config
      args = ["-U", config[:username], "-h", config[:host], "-d", config[:database], "-f", file_path]
      args.each_with_index do |arg, idx| # scan for empty args and remove them
        args.delete_at(idx - 1) if arg.nil? || arg.empty?
      end
      cmd = "pg_dump #{args.compact.join(" ")}"
      puts cmd
      system(cmd)
    when "sqlite3"
      config = sqlite3_config
      system("sqlite3 #{config[:database]} .dump > #{file_path}")
    else
      raise "Invalid db_type"
    end
  end
end

puts "DEBUG: command: #{command.inspect}"
class Processor
  attr_accessor :command, :logger, :db, :openai_client, :pastel

  def initialize(command)
    @db = DBHandler.new(:postgres)
    @db.connect
    # ActiveRecord::Base.establish_connection(@db.db_config)
    @command = command
    @logger = Logger.new("raindrop_io.log")
    @logger.level = Logger::DEBUG
    # set the access token and logger
    RaindropIo::Api.configure do |config|
      config.api_token = command.token
      config.logger = @logger
    end
    @openai_client = OpenAI::Client.new(access_token: ENV["OPENAI_API_KEY"])
    @pastel = ::Pastel.new
  end

  def self.load_all_raindrops(col_id, delay: 2)
    drops = RaindropIo::Raindrop.raindrops(col_id)
    total_pages = drops[:total] / RaindropIo::Raindrop.default_page_size
    (0...total_pages).each do |page|
      drops = RaindropIo::Raindrop.raindrops(col_id, page: page)
      sleep_counter = 0

      drops[:items].each do |drop|
        if Raindrop.where(_id: drop._id).empty? # avoid dupes
          column_names = ::Raindrop.column_names
          data = drop.to_hash
          # Separate the data into known and extra attributes, since things change
          known_attrs = data.select { |k, v| column_names.include?(k) }
          unknown_attrs = data.except(*column_names)
          known_attrs["extra_data"] = unknown_attrs
          drop = Raindrop.create!(known_attrs)
          ap drop.as_json
          sleep_counter += 1
          if sleep_counter % 10 == 0
            puts "Sleeping for #{delay} seconds"
            sleep delay
          end
        else
          puts "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
          # logger.debug "Duplicate link, skipping _id: #{drop._id} #{drop.link}"
        end
      end
      ap "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
      # logger.debug "Page: #{page} of #{total_pages}.  Raindrop.count: #{::Raindrop.count}"
    end
  end

  def self.load_all_collections(delay: 2)
    collections = RaindropIo::Collection.all
    # is there paging?  how do I get everything including their children?
    collections.each do |col|
      if Collection.where(_id: col._id).empty?
        column_names = Collection.column_names
        data = col.to_hash
        known_attrs = data.select { |k, v| column_names.include?(k) }
        unknown_attrs = data.except(*column_names)
        known_attrs["extra_data"] = unknown_attrs
        Collection.create!(known_attrs)
        # sleep delay
      else
        puts "Duplicate collection, skipping _id: #{col._id} #{col.title}"
        # logger.debug "Duplicate collection, skipping _id: #{col._id} #{col.title}"
      end
    end
    Collection.all.map { |col| ap [col._id, col.title] }
  end

  def load_user
    user = RaindropIo::User.current_user
    if User.where(_id: user._id).empty?
      User.create!(_id: user._id, data: user.to_hash)
    end
  end

  def main
    case command.object
    when "command", "cmd"
      case command.command
      when "categorize"
        # find all raindrops that are not categorized
        Raindrop.where("collection ->> 'oid' = ?", "-1").each do |drop|
          category = drop.pick_category(client: @openai_client, collections: Collection.all)
          drop.move_to_collection(category)
          drop.save!
        end
        binding.pry # rubocop:disable Lint/Debugger
      when "debug"
        binding.pry # rubocop:disable Lint/Debugger
      when "line"
        # db.migrate!
        # db.drop!
        # self.class.load_all_raindrops(0)
        # load_user
        # ap models = @openai_client.models.list
        # drop = Raindrop.find_by(_id: 775506251)
        prompt = TTY::Prompt.new
        uncategorized_drops = Raindrop.where("collection ->> 'oid' = ?", "-1")
        n = 0
        uncategorized_drops.each do |drop|
          n += 1
          puts "\n\n\n\n(#{n}/#{uncategorized_drops.size}, #{uncategorized_drops.size - n} left) #{pastel.yellow.bold(drop.title)} - #{drop.link}"

          drop.summarize_to_note(client: openai_client)
          drop.tag(client: openai_client)
          puts "tags: #{drop.tags.map { |t| pastel.cyan.bold(t) }.join(", ")}\n"
          target_collection = drop.pick_category(client: @openai_client, collections: Collection.all)
          if target_collection.nil?
            puts pastel.red("No target collection found for #{drop.title}\nDrop id: #{drop.id}/#{drop._id}  #{pastel.bold(drop.title)}")
            binding.pry # rubocop:disable Lint/Debugger
            next
          end
          puts "drop.note: #{pastel.red.bold(drop.note)}\n"
          drop.move_to_collection(target_collection)
          puts "\n"

          print "Contine [enter], (r)eload collections, (u)se different url, (m)ove to another collection, (f)ix summary, (d)ebug, dele(t)e drop - for later recat, (q)uit : "

          # design notes:
          #  * need to adjust tags
          #  * change category
          #  * change summary, maybe the url is not giving useful info
          #  * there might be tags or keywords that push to a category that we need to remember
          #  * a way to create new tags and categories, and push past and future categorizations to them
          #  TODO: maybe add descriptions to categories to help guide further refinements to the llm categorization
          ans = $stdin.gets.chomp
          case ans
          when "d"
            binding.pry # rubocop:disable Lint/Debugger
            next
          when "q"
            exit 0
          when "r"
            self.class.load_all_collections
            break
          when "t"
            drop.destroy
            next
          when "m"
            all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }.sort
            new_category = prompt.select("Select a category", all_categories, per_page: 20)
            target_collection = Collection.find_by(title: new_category)
            drop.move_to_collection(target_collection)
            drop.save!
          when "u"
            new_url = prompt.ask("Enter new url: ")
            drop.summarize_to_note(client: openai_client, alternative_url: new_url)
            drop.tag(client: openai_client)
            puts "new drop.note: #{pastel.red.bold(drop.note)}\n"
            if prompt.yes?("use new summary?")
              all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }
              new_category = prompt.select("Select a category", all_categories, per_page: 20)
              target_collection = Collection.find_by(title: new_category)
              drop.move_to_collection(target_collection)
              puts "saving..."
              drop.save!
            else
              puts "exiting.."
              exit 1
            end
          when "f"
            puts "Current note: #{drop.id}/#{drop._id} #{drop.link} \n#{drop.note}"
            ans = prompt.select("Edit current drop, or load another by _id?", %w[edit load])
            if ans == "load"
              print "Enter id: "
              id = $stdin.gets.chomp
              drop = Raindrop.find_by(_id: id)
            end
            binding.pry # rubocop:disable Lint/Debugger
            drop.save!
          when ""
            puts "processing...\n"
          else
            puts "unknown command #{ans.inspect}\n\n"
            binding.pry # rubocop:disable Lint/Debugger
            break
          end

          drop.save!
          # ask to continue, or change the target collection
          # if prompt.select("Continue or change target collection?", %w[continue change]) == "change"
          #   all_categories = Collection.all.map { |c| c.title }.reject { |i| i == "" }
          #   new_category = prompt.select("Select a category", all_categories, per_page: 20)
          #   target_collection = Collection.find_by(title: new_category)
          #   drop.move_to_collection(target_collection)
          #   drop.save!
          # end
          drop.push_data!
          puts "Updated remote with title: #{pastel.yellow(drop.title)}\n#{pastel.red.bold(drop.note)}\n#{drop.tags.map { |t| pastel.cyan(t) }.join(", ")}\n"
        end

        # drop.summarize_to_note(client: openai_client)
        # drop.tag(client: openai_client)
        # target_collection = drop.pick_category(client: @openai_client, collections: Collection.all)
        # drop.move_to_collection(target_collection)
        # drop.save!
        # drop.push_data!
        # binding.pry # rubocop:disable Lint/Debugger
      end
    when "collection"
      case command.command
      when "list"
        collections = Collection.all
        ap collections.as_json
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "raindrop"
      case command.command
      when "get"
        ap RaindropIo::Raindrop.get(command.options[:id])
      when "post"
        ap RaindropIo::Raindrop.post(command.options[:id])
      when "put"
        ap RaindropIo::Raindrop.put(command.options[:id])
      when "delete"
        ap RaindropIo::Raindrop.delete(command.options[:id])
      when "list"
        raindrops = Raindrop.all
        ap raindrops.as_json
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    when "user"
      case command.command
      when "delete"
        ap RaindropIo::User.delete(command.options[:id])
      when "current_user"
        ap RaindropIo::User.current_user
      else
        warn "ERROR: Command '#{command.command}' not found\n\n"
      end
    else
      puts "ERROR: command '#{command.object}' not found\n\n"
    end
  end
end

processor = Processor.new(command)
processor.main
